require('dotenv').config();

// TEST THE PATCHED PUPPETEER-SCREEN-RECORDER WITH DIRECT RTMP OUTPUT
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors'); // Import the cors package
const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
puppeteer.use(StealthPlugin());
const path = require('path');
const fs = require('fs');

// Import the PATCHED puppeteer-screen-recorder
const { PuppeteerScreenRecorder } = require('./puppeteer-screen-recorder-main/build/main/index.js');

// Import cookies helper
let CookiesHelper;
try {
    CookiesHelper = require('./cookies-helper');
    console.log('‚úÖ CookiesHelper imported successfully');
} catch (error) {
    console.log('‚ö†Ô∏è CookiesHelper import failed, creating dummy class:', error.message);
    CookiesHelper = class {
        async applyCookiesToPage(page) {
            console.log('üç™ Using dummy cookies helper (no cookies applied)');
        }
    };
}

// Helper function to convert duration string to seconds
function convertDurationToSeconds(duration) {
    if (!duration || typeof duration !== 'string') return 0;
    
    // Parse duration format "HH:MM:SS.MS" or "MM:SS"
    const parts = duration.split(':');
    let seconds = 0;
    
    if (parts.length === 3) {
        // HH:MM:SS.MS format
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const secs = parseFloat(parts[2]) || 0;
        seconds = hours * 3600 + minutes * 60 + secs;
    } else if (parts.length === 2) {
        // MM:SS format
        const minutes = parseInt(parts[0]) || 0;
        const secs = parseFloat(parts[1]) || 0;
        seconds = minutes * 60 + secs;
    }
    
    return seconds;
}

// Auto-generate required files for cross-device deployment
function ensureRequiredFiles() {
    console.log('üîß Checking and creating required files for cross-device deployment...');
    
    // 1. Auto-create cookies.json if it doesn't exist
    const cookiesPath = path.join(__dirname, 'cookies.json');
    if (!fs.existsSync(cookiesPath)) {
        const defaultCookies = [];
        fs.writeFileSync(cookiesPath, JSON.stringify(defaultCookies, null, 2));
        console.log('‚úÖ Created default cookies.json file');
    }
    
    // 2. Auto-create browser-state-data.txt if it doesn't exist
    const stateDataPath = path.join(__dirname, 'browser-state-data.txt');
    if (!fs.existsSync(stateDataPath)) {
        const defaultStateData = {
            "timestamp": new Date().toLocaleTimeString(),
            "viewport": {
                "basic": {
                    "innerWidth": 1212,
                    "innerHeight": 701,
                    "outerWidth": 1228,
                    "outerHeight": 795,
                    "screenX": 251,
                    "screenY": 66,
                    "scrollX": 49,
                    "scrollY": 430,
                    "devicePixelRatio": 1
                },
                "visualViewport": {
                    "width": 1206,
                    "height": 695,
                    "offsetLeft": 0,
                    "offsetTop": 0,
                    "pageLeft": 49,
                    "pageTop": 430,
                    "scale": 1
                }
            },
            "screen": {
                "width": 1536,
                "height": 864,
                "availWidth": 1536,
                "availHeight": 824,
                "colorDepth": 24,
                "pixelDepth": 24
            },
            "browser": {
                "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "language": "en-US",
                "platform": "Win32",
                "cookieEnabled": true
            },
            "deployment": {
                "autoGenerated": true,
                "createdAt": new Date().toISOString(),
                "note": "This file was auto-generated for cross-device deployment. Modify viewport settings as needed for your target device."
            }
        };
        
        fs.writeFileSync(stateDataPath, JSON.stringify(defaultStateData, null, 2));
        console.log('‚úÖ Created default browser-state-data.txt file');
    }
    
    // 3. Create videos directory if it doesn't exist
    const videosDir = path.join(__dirname, 'videos');
    if (!fs.existsSync(videosDir)) {
        fs.mkdirSync(videosDir, { recursive: true });
        console.log('‚úÖ Created videos directory');
    }
    
    console.log('‚úÖ All required files checked and created successfully');
}

// Initialize required files on server startup
ensureRequiredFiles();

// Verify .env variables are loaded
console.log('‚úÖ PRIMARY_DOMAIN:', process.env.PRIMARY_DOMAIN);

// This URL will be the public Cloudflare Tunnel address, which doesn't need a port.
const app = express();
const server = http.createServer(app);

// Configure CORS for Socket.IO to use environment variables
const allowedOrigins = process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : ["https://obs.liveenity.com", "http://localhost:3005"];
console.log('‚úÖ Allowed CORS origins for Socket.IO:', allowedOrigins);

const io = new Server(server, {
    cors: {
        origin: allowedOrigins,
        methods: ["GET", "POST"],
        credentials: true
    }
});

// Use the cors middleware for all Express routes
app.use(cors({ origin: allowedOrigins, credentials: true }));

// Middleware to block direct browser access to the root URL
app.use((req, res, next) => {
    // Allow requests to API endpoints and from localhost to pass through
    if (req.path.startsWith('/api/') || req.hostname === 'localhost' || req.hostname === '127.0.0.1') {
        return next();
    }

    // Block other requests to the root
    if (req.path === '/') {
        // Also check if the request is for a file that might be served statically, like index.html
        if (req.path === '/' || req.path.toLowerCase() === '/index.html') {
             return res.status(403).send('Access Denied');
        }
    }

    next();
});

// Serve static files from the 'public' directory for local development and API access
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        activeStreams: activeStreams.size 
    });
});

// Multiple concurrent streams management
const activeStreams = new Map(); // streamId -> { browser, page, recorder, interval }
let streamCounter = 0;

// Socket.IO events
io.on('connection', (socket) => {
    console.log('üîå Client connected');

    // Handle file editing requests from the frontend
    socket.on('get_file_content', ({ filename }, callback) => {
        console.log(`üìÇ Request to get content of: ${filename}`);
        // Security: Only allow editing of specific, safe-to-edit files
        if (filename !== 'cookies.json' && filename !== 'browser-state-data.txt') {
            console.error(`‚ùå Access denied for file: ${filename}`);
            return callback({ error: 'Access Denied. You can only edit cookies.json or browser-state.json.' });
        }

        const filePath = path.join(__dirname, filename);
        fs.readFile(filePath, 'utf8', (err, content) => {
            if (err) {
                console.error(`‚ùå Error reading file ${filename}:`, err);
                 if (err.code === 'ENOENT') {
                    console.log(`‚ö†Ô∏è File not found: ${filename}. Returning default empty content.`);
                    // Return a default empty state based on the file type
                    const defaultContent = filename === 'cookies.json' ? '[]' : '{}';
                    return callback({ content: defaultContent });
                }
                return callback({ error: `File not found or could not be read.` });
            }
            callback({ content });
        });
    });

    socket.on('save_file_content', ({ filename, content }, callback) => {
        console.log(`üíæ Request to save content to: ${filename}`);
        // Security: Only allow editing of specific, safe-to-edit files
        if (filename !== 'cookies.json' && filename !== 'browser-state-data.txt') {
            console.error(`‚ùå Access denied for file: ${filename}`);
            return callback({ error: 'Access Denied. You can only edit cookies.json or browser-state.json.' });
        }

        try {
            // Validate JSON content before saving to prevent corruption
            JSON.parse(content);
        } catch (e) {
            console.error(`‚ùå Invalid JSON content for ${filename}:`, e.message);
            return callback({ error: 'Invalid JSON format. Please correct and try again.' });
        }

        const filePath = path.join(__dirname, filename);
        fs.writeFile(filePath, content, 'utf8', (err) => {
            if (err) {
                console.error(`‚ùå Error writing to file ${filename}:`, err);
                return callback({ error: 'Failed to save file.' });
            }
            console.log(`‚úÖ Successfully saved ${filename}`);
            callback({ success: true });
        });
    });

    socket.on('startPatchedRTMPStream', async (data) => {
        const { url, rtmpUrl, streamKey, bitrate = 2500, fps = 15, resolution = '1280x720', scrollX = 0, scrollY = 0, zoomLevel = 100, viewportWidth = 1280, viewportHeight = 720, maxDuration = null } = data;
        
        console.log(`üì• Received startPatchedRTMPStream request:`, { url, rtmpUrl, streamKey, bitrate, fps, resolution, scrollX, scrollY, zoomLevel, viewportWidth, viewportHeight, maxDuration });
        
        // Convert maxDuration - handle both string and number formats
        let maxDurationSeconds = null;
        if (maxDuration) {
            if (typeof maxDuration === 'string') {
                maxDurationSeconds = convertDurationToSeconds(maxDuration);
            } else if (typeof maxDuration === 'number') {
                maxDurationSeconds = maxDuration; // Already in seconds
            }
        }
        console.log(`‚è∞ Duration limit: ${maxDuration} ‚Üí ${maxDurationSeconds} seconds`);
        
        // Create unique stream ID
        const streamId = ++streamCounter;
        
        try {
            const rtmpEndpoint = `${rtmpUrl}/${streamKey}`;
            console.log(`üöÄ [Stream ${streamId}] Starting PATCHED RTMP streaming for: ${url} ‚Üí ${rtmpEndpoint}`);
            console.log(`üìä Active streams: ${activeStreams.size + 1}`);

            // Parse resolution from control panel to set viewport
            const [captureWidth, captureHeight] = resolution.split('x').map(Number);
            console.log(`üñ•Ô∏è [Stream ${streamId}] Setting viewport to: ${captureWidth}x${captureHeight}`);
            
            // Launch dedicated browser for this stream
            console.log(`üåê [Stream ${streamId}] Launching dedicated browser...`);
            let browser, page;
            let exactHardcoded; // To be used across blocks

            try {
                // Find Chrome executable
                let chromePath = 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe';
                if (!fs.existsSync(chromePath)) {
                    chromePath = 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe';
                    console.log(`üîç [Stream ${streamId}] Trying alternative Chrome path...`);
                }
                if (!fs.existsSync(chromePath)) {
                    console.log(`üîç [Stream ${streamId}] Using system default Chrome...`);
                    chromePath = undefined;
                }
                console.log(`üåê [Stream ${streamId}] Using Chrome at: ${chromePath || 'system default'}`);

                // Load exact browser state from file
                try {
                    const data = fs.readFileSync('browser-state-data.txt', 'utf8');
                    const stateData = JSON.parse(data);

                    // --- Definitive Fix: Correctly map all nested properties ---
                    exactHardcoded = {
                        windowWidth: stateData.viewport?.basic?.outerWidth,
                        windowHeight: stateData.viewport?.basic?.outerHeight,
                        positionX: stateData.viewport?.basic?.screenX,
                        positionY: stateData.viewport?.basic?.screenY,
                        scrollX: stateData.viewport?.basic?.scrollX,
                        scrollY: stateData.viewport?.basic?.scrollY,
                        deviceScaleFactor: stateData.viewport?.basic?.devicePixelRatio,
                        userAgent: stateData.browser?.userAgent
                    };
                    console.log('‚úÖ Successfully loaded and correctly mapped browser state from file.');
                } catch (err) {
                    console.error('‚ùå Error reading or parsing browser state file, using fallback values:', err);
                    exactHardcoded = {
                        windowWidth: 1280, windowHeight: 720, positionX: 100, positionY: 100,
                        scrollX: 0, scrollY: 0, deviceScaleFactor: 1,
                        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                    };
                }

                const launchArgs = [
                    '--no-sandbox', '--disable-setuid-sandbox', '--disable-infobars',
                    '--ignore-certifcate-errors', '--ignore-certifcate-errors-spki-list',
                    `--window-size=${exactHardcoded.windowWidth},${exactHardcoded.windowHeight}`,
                    `--window-position=${exactHardcoded.positionX},${exactHardcoded.positionY}`,
                    `--force-device-scale-factor=${exactHardcoded.deviceScaleFactor}`,
                    `--user-agent=${exactHardcoded.userAgent}`,
                    `--user-data-dir=./chrome-data-rtmp-${streamId}`,
                    '--disable-dev-shm-usage', '--disable-web-security', '--disable-features=VizDisplayCompositor'
                ];
                
                console.log(`ü™ü [Stream ${streamId}] EXACT SIZE: ${exactHardcoded.windowWidth}x${exactHardcoded.windowHeight}`);
                console.log(`üìç [Stream ${streamId}] EXACT POSITION: ${exactHardcoded.positionX},${exactHardcoded.positionY}`);
                console.log(`üìú [Stream ${streamId}] EXACT SCROLL: ${exactHardcoded.scrollX},${exactHardcoded.scrollY}`);

                browser = await puppeteer.launch({
                    headless: false, executablePath: chromePath, args: launchArgs,
                    ignoreDefaultArgs: ['--enable-automation'], defaultViewport: null
                });

                const pages = await browser.pages();
                page = pages.length > 0 ? pages[0] : await browser.newPage();

                console.log(`‚úÖ [Stream ${streamId}] Browser launched. Viewport will be determined by window size.`);

                const cookiesHelper = new CookiesHelper();
                await cookiesHelper.applyCookiesToPage(page);
                console.log(`üç™ [Stream ${streamId}] Cookies applied to browser`);

                await page.setRequestInterception(true);
                page.on('request', (request) => {
                    const blockedDomains = ['facebook.net', 'facebook.com', 'google-analytics.com', 'googletagmanager.com', 'doubleclick.net'];
                    if (blockedDomains.some(domain => request.url().includes(domain))) {
                        request.abort();
                    } else {
                        request.continue();
                    }
                });
                console.log(`‚úÖ [Stream ${streamId}] Request blocking enabled.`);

            } catch (browserError) {
                console.error(`‚ùå [Stream ${streamId}] Browser launch error:`, browserError);
                throw browserError;
            }

            // Navigate to URL
            console.log(`üåê [Stream ${streamId}] Navigating to: ${url}`);
            console.log(`üîç [Stream ${streamId}] DEBUG: About to call page.goto...`);
            try {
                console.log(`üîç [Stream ${streamId}] DEBUG: Calling page.goto with domcontentloaded...`);
                await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });
                console.log(`üß≠ [Stream ${streamId}] Navigated to ${url}`);

                // === START: Exact Viewport and State Restoration ===

                // 1. Force full viewport usage with aggressive CSS
                console.log(`üîß [Stream ${streamId}] Injecting aggressive CSS to force full viewport...`);
                await page.evaluate(() => {
                    const style = document.createElement('style');
                    style.textContent = `
                        html, body {
                            width: 100vw !important;
                            height: 100vh !important;
                            zoom: 1 !important;
                            margin: 0 !important;
                            padding: 0 !important;
                            overflow: visible !important; /* Allow scrolling */
                        }
                    `;
                    document.head.appendChild(style);
                    window.dispatchEvent(new Event('resize'));
                    console.log('‚úÖ Injected aggressive CSS to override inline styles.');
                });

                // 2. Set exact scroll position after a short delay to allow layout to settle
                await new Promise(resolve => setTimeout(resolve, 250)); // 250ms delay

                console.log(`üìú [Stream ${streamId}] Setting FINAL scroll position to: ${exactHardcoded.scrollX}, ${exactHardcoded.scrollY}`);
                await page.evaluate((scrollX, scrollY) => {
                    // Use multiple methods to ensure scroll is set reliably
                    document.documentElement.scrollLeft = scrollX;
                    document.documentElement.scrollTop = scrollY;
                    document.body.scrollLeft = scrollX;
                    document.body.scrollTop = scrollY;
                    window.scrollTo(scrollX, scrollY);
                }, exactHardcoded.scrollX, exactHardcoded.scrollY);

                // 3. Run comprehensive detection and verification
                console.log(`üîç [Stream ${streamId}] Verifying final browser state...`);
                const finalState = await page.evaluate(() => {
                    return {
                        viewport: `${window.innerWidth}x${window.innerHeight}`,
                        windowSize: `${window.outerWidth}x${window.outerHeight}`,
                        position: `${window.screenX},${window.screenY}`,
                        scroll: `${window.scrollX},${window.scrollY}`,
                        htmlClient: `${document.documentElement.clientWidth}x${document.documentElement.clientHeight}`
                    };
                });

                console.log(`üìä [Stream ${streamId}] VERIFICATION COMPLETE:`);
                console.log(`   - Window Size:  Requested: ${exactHardcoded.windowWidth || 'N/A'}x${exactHardcoded.windowHeight || 'N/A'} | Actual: ${finalState.windowSize}`);
                console.log(`   - Position:     Requested: ${exactHardcoded.positionX || 'N/A'},${exactHardcoded.positionY || 'N/A'} | Actual: ${finalState.position}`);
                console.log(`   - Viewport:     Requested: ${exactHardcoded.viewportWidth || 'N/A'}x${exactHardcoded.viewportHeight || 'N/A'} | Actual: ${finalState.viewport}`);
                console.log(`   - Scroll:       Requested: ${exactHardcoded.scrollX || 'N/A'},${exactHardcoded.scrollY || 'N/A'} | Actual: ${finalState.scroll}`);
                console.log(`   - HTML Size:    ${finalState.htmlClient}`);
                console.log(`üéØ [Stream ${streamId}] Browser state restoration complete.`);

                // === END: Exact Viewport and State Restoration ===

                console.log(`üìπ [Stream ${streamId}] Page loaded, starting PATCHED RTMP streaming...`);
            } catch (navError) {
                console.error(`‚ùå [Stream ${streamId}] Navigation error:`, navError);
                console.error(`‚ùå [Stream ${streamId}] Navigation error details:`, navError.message);
                console.error(`‚ùå [Stream ${streamId}] Navigation error stack:`, navError.stack);
                throw navError;
            }
            
            // Keep page active
            try {
                await page.bringToFront();
                await page.focus('body');
                console.log(`‚úÖ [Stream ${streamId}] Page activated and focused`);
            } catch (focusError) {
                console.error(`‚ùå [Stream ${streamId}] Page focus error:`, focusError);
                throw focusError;
            }

            // Configure recording for RTMP streaming using control panel settings
            const [width, height] = resolution.split('x').map(Number);
            const recordingConfig = {
                followNewTab: false,
                fps: fps,                   // FPS from control panel
                videoFrame: {
                    width: width,           // Width from control panel resolution
                    height: height,         // Height from control panel resolution
                },
                videoCrf: 28,               // Good quality for streaming
                videoCodec: 'libx264',      // H.264 codec
                videoPreset: 'ultrafast',   // Fastest encoding for real-time
                videoBitrate: bitrate,      // Bitrate from control panel (2500)
                aspectRatio: '16:9',
                autopad: {
                    color: 'black'
                },
                streamId: streamId          // Pass Stream ID for FFMPEG process tracking
            };

            // Create recorder with PATCHED library
            console.log(`üé¨ [Stream ${streamId}] Creating PATCHED PuppeteerScreenRecorder...`);
            const recorder = new PuppeteerScreenRecorder(page, recordingConfig);
            console.log(`‚úÖ [Stream ${streamId}] PATCHED recorder created`);

            // Start recording DIRECTLY TO RTMP (using patched library!)
            console.log(`üì° [Stream ${streamId}] Starting PATCHED recording DIRECTLY to RTMP:`, rtmpEndpoint);
            await recorder.start(rtmpEndpoint);
        
            console.log(`‚úÖ [Stream ${streamId}] PATCHED RTMP streaming started successfully`);
            
            // Set up FFMPEG duration monitoring with real stderr parsing
            let lastDuration = '';
            const ffmpegMonitorInterval = setInterval(() => {
                try {
                    // Access the FFMPEG process directly from the recorder
                    if (recorder && recorder.streamWriter && recorder.streamWriter.ffmpegProcess) {
                        const ffmpegProcess = recorder.streamWriter.ffmpegProcess;
                        
                        // Listen to stderr for duration updates
                        if (ffmpegProcess.stderr && !ffmpegProcess._durationListenerAdded) {
                            ffmpegProcess._durationListenerAdded = true;
                            
                            ffmpegProcess.stderr.on('data', (data) => {
                                const message = data.toString();
                                
                                // Parse duration from FFMPEG stderr (e.g., "time=00:00:20.06")
                                const timeMatch = message.match(/time=(\d{2}:\d{2}:\d{2}\.\d{2})/);
                                if (timeMatch) {
                                    const duration = timeMatch[1];
                                    if (duration !== lastDuration) {
                                        lastDuration = duration;
                                        
                                        // Update stream data
                                        const stream = activeStreams.get(streamId);
                                        if (stream) {
                                            stream.ffmpegDuration = duration;
                                            stream.lastFFMPEGUpdate = Date.now();
                                            
                                            // Check if stream should auto-stop based on duration limit
                                            if (stream.maxDuration && duration && !stream.autoStopping) {
                                                const currentSeconds = convertDurationToSeconds(duration);
                                                const maxSeconds = stream.maxDuration; // maxDuration is already in seconds
                                                
                                                if (currentSeconds >= maxSeconds) {
                                                    console.log(`‚è∞ [Stream ${streamId}] Duration limit reached (${duration}/${stream.maxDuration}) - auto-stopping...`);
                                                    
                                                    // Mark as auto-stopping to prevent multiple triggers
                                                    stream.autoStopping = true;
                                                    
                                                    // Auto-stop the stream
                                                    setTimeout(async () => {
                                                        try {
                                                            if (activeStreams.has(streamId)) {
                                                                await stopStreamById(streamId);
                                                                io.emit('streamAutoStopped', {
                                                                    streamId: streamId,
                                                                    reason: 'Duration limit reached',
                                                                    duration: duration,
                                                                    maxDuration: stream.maxDuration
                                                                });
                                                            }
                                                        } catch (error) {
                                                            console.log(`‚ùå [Stream ${streamId}] Auto-stop error:`, error.message);
                                                        }
                                                    }, 1000);
                                                    return; // Don't send duration update if stopping
                                                }
                                            }
                                        }
                                        
                                        // Send to /lives page
                                        io.emit('durationUpdate', {
                                            streamId: streamId,
                                            duration: duration
                                        });
                                    }
                                }
                            });
                            console.log(`‚úÖ [Stream ${streamId}] FFMPEG duration monitoring attached`);
                        }
                    }
                } catch (error) {
                    console.log(`‚ùå [Stream ${streamId}] FFMPEG monitor error:`, error.message);
                }
            }, 2000);
            
            // Set up file monitoring for real-time viewport updates (same as puppeteer-exact-viewport.js)
            const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
            let fileWatcher = null;
            
            console.log(`üëÅÔ∏è [Stream ${streamId}] Setting up file monitoring for real-time viewport updates...`);
            console.log(`üìÅ [Stream ${streamId}] Monitoring: ${stateFilePath}`);
            
            // Create default state file if it doesn't exist (copy from browser-state-data.txt)
            if (!fs.existsSync(stateFilePath)) {
                const defaultStateFile = path.join(__dirname, 'browser-state-data.txt');
                if (fs.existsSync(defaultStateFile)) {
                    const defaultContent = fs.readFileSync(defaultStateFile, 'utf8');
                    fs.writeFileSync(stateFilePath, defaultContent);
                    console.log(`üìÑ [Stream ${streamId}] Created state file from default data`);
                } else {
                    // Create minimal state file
                    const minimalState = {
                        timestamp: new Date().toLocaleTimeString(),
                        viewport: {
                            basic: {
                                scrollX: exactHardcoded.scrollX,
                                scrollY: exactHardcoded.scrollY
                            }
                        }
                    };
                    fs.writeFileSync(stateFilePath, JSON.stringify(minimalState, null, 2));
                    console.log(`üìÑ [Stream ${streamId}] Created minimal state file`);
                }
            }
            
            const updateViewportFromFile = async () => {
                try {
                    if (fs.existsSync(stateFilePath)) {
                        // Add delay to ensure file write is complete
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const fileContent = fs.readFileSync(stateFilePath, 'utf8');
                        const stateData = JSON.parse(fileContent);
                        
                        console.log(`üîç [Stream ${streamId}] Parsing state data for viewport updates...`);
                        
                        // Check for scroll data in the correct structure: viewport.basic.scrollX/scrollY
                        if (stateData.viewport && stateData.viewport.basic) {
                            const newScrollX = stateData.viewport.basic.scrollX || 0;
                            const newScrollY = stateData.viewport.basic.scrollY || 0;
                            
                            console.log(`üìú [Stream ${streamId}] Updating scroll position: ${newScrollX}, ${newScrollY}`);
                            
                            // Update scroll position with multiple methods for reliability
                            await page.evaluate((scrollX, scrollY) => {
                                console.log(`Browser: Applying scroll ${scrollX}, ${scrollY}`);
                                window.scrollTo(scrollX, scrollY);
                                document.documentElement.scrollLeft = scrollX;
                                document.documentElement.scrollTop = scrollY;
                                document.body.scrollLeft = scrollX;
                                document.body.scrollTop = scrollY;
                            }, newScrollX, newScrollY);
                            
                            // Verify the scroll update
                            const actualScroll = await page.evaluate(() => ({
                                x: window.scrollX || window.pageXOffset,
                                y: window.scrollY || window.pageYOffset
                            }));
                            
                            console.log(`‚úÖ [Stream ${streamId}] Scroll updated - Target: ${newScrollX},${newScrollY} | Actual: ${actualScroll.x},${actualScroll.y}`);
                        } else {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] No viewport.basic scroll data found in state file`);
                        }
                        
                        // Check for zoom data (if present)
                        if (stateData.zoom && stateData.zoom.level !== undefined) {
                            const zoomLevel = stateData.zoom.level;
                            console.log(`üîç [Stream ${streamId}] Updating zoom level: ${zoomLevel}`);
                            
                            await page.evaluate((zoom) => {
                                document.body.style.zoom = zoom;
                            }, zoomLevel);
                            
                            console.log(`‚úÖ [Stream ${streamId}] Zoom updated to: ${zoomLevel}`);
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå [Stream ${streamId}] Error updating viewport from file:`, error.message);
                    console.error(`Stack trace:`, error.stack);
                }
            };
            
            // Set up file watcher
            try {
                fileWatcher = fs.watch(stateFilePath, { persistent: true }, (eventType, filename) => {
                    if (eventType === 'change') {
                        console.log(`üìÅ [Stream ${streamId}] File changed: ${filename}`);
                        updateViewportFromFile();
                    }
                });
                console.log(`‚úÖ [Stream ${streamId}] File watcher established for real-time updates`);
            } catch (error) {
                console.error(`‚ùå [Stream ${streamId}] Error setting up file watcher:`, error.message);
            }

            // Add page interaction to trigger frame capture (without changing page content)
            console.log(`üéØ [Stream ${streamId}] Adding page interaction to trigger frame capture...`);
            const interactionInterval = setInterval(async () => {
              try {
                // Only wake up the page, don't change anything visual
                await page.bringToFront();
                // Minimal mouse movement that doesn't affect content
                await page.mouse.move(10, 10);
                await page.mouse.move(11, 11);
              } catch (e) {
                // Ignore interaction errors
              }
            }, 5000);

            // Store stream data
            activeStreams.set(streamId, {
                browser,
                page,
                recorder,
                interval: interactionInterval,
                ffmpegMonitorInterval,
                fileWatcher,
                stateFilePath,
                rtmpEndpoint,
                url,
                resolution,
                startTime: Date.now(),
                ffmpegDuration: '00:00:00',
                maxDuration: maxDurationSeconds,
                lastFFMPEGUpdate: Date.now(),
                socketId: socket.id
            });

            socket.emit('streamStarted', { 
                streamId,
                message: `PATCHED RTMP streaming started successfully! Stream ID: ${streamId}` 
            });

        } catch (error) {
            console.error(`‚ùå [Stream ${streamId || 'Unknown'}] PATCHED streaming error:`, error);
            // Clean up any partially created resources
            if (typeof browser !== 'undefined' && browser) {
                try {
                    await browser.close();
                } catch (e) {
                    console.error(`‚ùå [Stream ${streamId || 'Unknown'}] Browser cleanup error:`, e);
                }
            }
            socket.emit('streamError', error.message);
        }
    });

    // Extract stop stream logic into reusable function
    async function stopStreamById(streamId) {
        if (!streamId || !activeStreams.has(streamId)) {
            throw new Error(`Stream ${streamId} not found`);
        }
        
        const stream = activeStreams.get(streamId);
        console.log(`üõë [Stream ${streamId}] Stopping PATCHED recorder...`);
        
        if (stream.interval) {
            clearInterval(stream.interval);
        }
        
        // Close file watcher
        if (stream.fileWatcher) {
            stream.fileWatcher.close();
            console.log(`‚úÖ [Stream ${streamId}] File watcher closed`);
        }
                
        if (stream.recorder) {
            // FORCE KILL FFMPEG PROCESS DIRECTLY (using Stream ID)
            console.log(`üî™ [Stream ${streamId}] FORCE KILLING FFMPEG process...`);
            
            try {
                if (stream.ffmpegPid) {
                    const { exec } = require('child_process');
                    exec(`taskkill /F /PID ${stream.ffmpegPid}`, (error, stdout, stderr) => {
                        if (error) {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] FFMPEG kill error: ${error.message}`);
                        } else {
                            console.log(`‚úÖ [Stream ${streamId}] FFMPEG process killed (PID: ${stream.ffmpegPid})`);
                        }
                    });
                } else {
                    console.log(`üîç [Stream ${streamId}] No direct PID access, searching for specific FFMPEG process...`);
                    
                    try {
                        // Try using WMI to find specific process
                        const streamRtmpUrl = stream.rtmpEndpoint;
                        const { exec } = require('child_process');
                        const { promisify } = require('util');
                        const execAsync = promisify(exec);
                        
                        const wmiResult = await execAsync(`powershell "Get-WmiObject Win32_Process -Filter \\"name='ffmpeg.exe'\\" | Where-Object {$_.CommandLine -like '*${streamRtmpUrl}*'} | Select-Object ProcessId"`);
                        
                        if (wmiResult.stdout.includes('ProcessId')) {
                            const pidMatch = wmiResult.stdout.match(/(\d+)/);
                            if (pidMatch) {
                                const targetPid = pidMatch[1];
                                console.log(`üéØ [Stream ${streamId}] Found specific FFMPEG PID via WMI: ${targetPid}`);
                                
                                await execAsync(`taskkill /F /PID ${targetPid}`);
                                console.log(`‚úÖ [Stream ${streamId}] Successfully killed specific FFMPEG process (PID: ${targetPid})`);
                            }
                        } else {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] Cannot identify specific process - skipping kill to protect other streams`);
                            console.log(`üõ°Ô∏è [Stream ${streamId}] Manual cleanup may be required for orphaned FFMPEG processes`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è [Stream ${streamId}] Could not list FFMPEG processes: ${error.message}`);
                        console.log(`‚ö†Ô∏è [Stream ${streamId}] Cannot identify specific process - skipping kill to protect other streams`);
                        console.log(`üõ°Ô∏è [Stream ${streamId}] Manual cleanup may be required for orphaned FFMPEG processes`);
                    }
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è [Stream ${streamId}] FFMPEG kill error:`, error.message);
            }
            
            await stream.recorder.stop();
            console.log(`‚úÖ [Stream ${streamId}] PATCHED recorder stopped`);
        }

        if (stream.browser) {
            await stream.browser.close();
            console.log(`‚úÖ [Stream ${streamId}] Browser closed`);
        }

        activeStreams.delete(streamId);
        console.log(`üõë [Stream ${streamId}] PATCHED streaming stopped`);
        console.log(`üìä Active streams: ${activeStreams.size}`);
        
        // Clean up state file
        try {
            const fs = require('fs');
            const stateFilePath = `rtmp-stream-${streamId}-state.txt`;
            if (fs.existsSync(stateFilePath)) {
                fs.unlinkSync(stateFilePath);
                console.log(`üóëÔ∏è [Stream ${streamId}] State file deleted: ${stateFilePath}`);
            }
        } catch (error) {
            console.log(`‚ö†Ô∏è [Stream ${streamId}] Could not delete state file: ${error.message}`);
        }
    }

    socket.on('stopStream', async (data) => {
        const { streamId } = data || {};
        
        try {
            if (streamId && activeStreams.has(streamId)) {
                await stopStreamById(streamId);
                socket.emit('streamStopped', { streamId });
                
            } else if (!streamId) {
                // Stop all streams for this socket
                const streamsToStop = [];
                for (const [id, stream] of activeStreams.entries()) {
                    if (stream.socketId === socket.id) {
                        streamsToStop.push(id);
                    }
                }
                
                for (const id of streamsToStop) {
                    const stream = activeStreams.get(id);
                    console.log(`üõë [Stream ${id}] Stopping PATCHED recorder...`);
                    
                    if (stream.interval) {
                        clearInterval(stream.interval);
                    }
                    
                    // Close file watcher
                    if (stream.fileWatcher) {
                        stream.fileWatcher.close();
                        console.log(`‚úÖ [Stream ${id}] File watcher closed`);
                    }
                    
                    if (stream.recorder) {
                        // FORCE KILL FFMPEG PROCESS DIRECTLY (using Stream ID)
                        console.log(`üî™ [Stream ${id}] FORCE KILLING FFMPEG process...`);
                        
                        try {
                            if (stream.ffmpegPid) {
                                const { exec } = require('child_process');
                                exec(`taskkill /F /PID ${stream.ffmpegPid}`, (error, stdout, stderr) => {
                                    if (error) {
                                        console.log(`‚ö†Ô∏è [Stream ${id}] FFMPEG kill error: ${error.message}`);
                                    } else {
                                        console.log(`‚úÖ [Stream ${id}] FFMPEG process killed successfully`);
                                    }
                                });
                            } else {
                                // Revert to original /lives page logic that worked
                                console.log(`üîç [Stream ${id}] No direct PID access, searching for specific FFMPEG process...`);
                                
                                const { execAsync } = require('util').promisify(require('child_process').exec);
                                // Debug: Show what we're searching for
                                console.log(`üîç [Stream ${id}] Searching for FFMPEG with pattern: rtmp-stream-${id}`);
                                
                                // Get all FFMPEG processes with their command lines for debugging
                                const debugQuery = `wmic process where "name='ffmpeg.exe'" get processid,commandline /format:list`;
                                
                                try {
                                    const debugResult = await execAsync(debugQuery);
                                    console.log(`üîç [Stream ${id}] All FFMPEG processes:`);
                                    console.log(debugResult.stdout);
                                } catch (debugError) {
                                    console.log(`‚ö†Ô∏è [Stream ${id}] Debug query failed: ${debugError.message}`);
                                }
                                
                                // More precise WMI query to avoid cross-stream conflicts - match the actual RTMP URL pattern
                                const wmiQuery = `wmic process where "name='ffmpeg.exe' and commandline like '%rtmp-stream-${id}'" get processid /format:value`;
                                
                                try {
                                    const wmiResult = await execAsync(wmiQuery);
                                    const pidMatch = wmiResult.stdout.match(/(\d+)/);
                                    if (pidMatch) {
                                        const targetPid = pidMatch[1];
                                        console.log(`üéØ [Stream ${id}] Found specific FFMPEG PID via WMI: ${targetPid}`);
                                        
                                        await execAsync(`taskkill /F /PID ${targetPid}`);
                                        console.log(`‚úÖ [Stream ${id}] Successfully killed specific FFMPEG process (PID: ${targetPid})`);
                                    } else {
                                        console.log(`‚ö†Ô∏è [Stream ${id}] No specific FFMPEG process found via WMI`);
                                    }
                                } catch (wmiError) {
                                    console.log(`‚ö†Ô∏è [Stream ${id}] WMI search error: ${wmiError.message}`);
                                }
                            }
                        } catch (killError) {
                            console.log(`‚ö†Ô∏è [Stream ${id}] Force kill error: ${killError.message}`);
                        }
                        
                        try {
                            await stream.recorder.stop();
                            console.log(`‚úÖ [Stream ${id}] PATCHED recorder stopped`);
                        } catch (stopError) {
                            console.log(`‚ö†Ô∏è [Stream ${id}] Recorder stop error: ${stopError.message}`);
                        }
                        
                    }

                    if (stream.browser) {
                        await stream.browser.close();
                        console.log(`‚úÖ [Stream ${id}] Browser closed`);
                    }

                    activeStreams.delete(id);
                    console.log(`üõë [Stream ${id}] PATCHED streaming stopped`);
                    
                    // Clean up state file
                    try {
                        const fs = require('fs');
                        const stateFilePath = `rtmp-stream-${id}-state.txt`;
                        if (fs.existsSync(stateFilePath)) {
                            fs.unlinkSync(stateFilePath);
                            console.log(`üóëÔ∏è [Stream ${id}] State file deleted: ${stateFilePath}`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è [Stream ${id}] Could not delete state file: ${error.message}`);
                    }
                }
                
                console.log(`üìä Active streams: ${activeStreams.size}`);
                socket.emit('streamStopped', { stoppedStreams: streamsToStop });
            } else {
                socket.emit('streamStopped', { streamId, message: `Stream ${streamId} was already stopped or not found` });
            }

        } catch (error) {
            console.error(`‚ùå [Stream ${streamId || 'Unknown'}] Stop error:`, error);
            socket.emit('streamError', error.message);
        }
    });

    socket.on('listStreams', () => {
        const streams = [];
        for (const [id, stream] of activeStreams.entries()) {
            streams.push({
                streamId: id,
                url: stream.url,
                rtmpEndpoint: stream.rtmpEndpoint,
                resolution: stream.resolution,
                startTime: stream.startTime,
                ffmpegDuration: stream.ffmpegDuration || '00:00:00',
                lastFFMPEGUpdate: stream.lastFFMPEGUpdate
            });
        }
        socket.emit('streamsList', { streams, totalActive: activeStreams.size });
    });

    // Get state file content for editing
    socket.on('getStreamStateFile', (data) => {
        const { streamId } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            if (fs.existsSync(stateFilePath)) {
                const content = fs.readFileSync(stateFilePath, 'utf8');
                socket.emit('streamStateFileContent', { streamId, content });
            } else {
                socket.emit('streamStateFileContent', { streamId, content: '' });
            }
        } catch (error) {
            console.error(`‚ùå Error reading state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    // Update state file content
    socket.on('updateStreamStateFile', (data) => {
        const { streamId, content } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            // Validate JSON
            JSON.parse(content);
            
            // Write to file
            fs.writeFileSync(stateFilePath, content, 'utf8');
            console.log(`‚úÖ Updated state file for stream ${streamId}`);
            
            socket.emit('streamStateFileUpdated', { streamId });
        } catch (error) {
            console.error(`‚ùå Error updating state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    socket.on('disconnect', async () => {
        console.log('üîå Client disconnected - streams continue running');
        // Streams now continue running independently of client connections
        // Use manual stop controls or server shutdown to stop streams
    });
});

// Serve main page
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'rtmp-control-panel.html'));
});

// Serve lives management page
app.get('/lives', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'lives.html'));
});


// API endpoints for file management
app.get('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    
    try {
        if (fs.existsSync(filePath)) {
            const content = fs.readFileSync(filePath, 'utf8');
            const jsonContent = JSON.parse(content);
            res.json(jsonContent);
        } else {
            // Return default content for missing files
            if (filename === 'cookies.json') {
                res.json([]);
            } else if (filename === 'browser-state-data.txt') {
                res.json({});
            } else {
                res.status(404).json({ error: 'File not found' });
            }
        }
    } catch (error) {
        console.error(`‚ùå Error reading ${filename}:`, error);
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    const { content } = req.body;
    
    try {
        // Validate JSON content
        JSON.parse(content);
        
        // Write file
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`‚úÖ Updated ${filename}`);
        
        res.json({ success: true, message: `${filename} updated successfully` });
    } catch (error) {
        console.error(`‚ùå Error saving ${filename}:`, error);
        res.status(500).json({ success: false, error: error.message });
    }
});

const PORT = 3005;
server.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ PATCHED RTMP Streaming Server running on http://0.0.0.0:${PORT}`);
    console.log(`üåê This server will be exposed publicly via Cloudflare Tunnel at: https://${process.env.PRIMARY_DOMAIN}`);
    console.log(`üéØ Pipeline: Chrome DevTools ‚Üí PATCHED puppeteer-screen-recorder ‚Üí RTMP`);
    console.log(`‚ú® NO MP4 FILES ‚Ä¢ DIRECT RTMP ‚Ä¢ PATCHED LIBRARY ‚Ä¢ REAL-TIME`);
    console.log(`üîß Library modification: pageVideoStreamWriter.ts now supports RTMP URLs`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë Shutting down server...');
    console.log(`üìä Cleaning up ${activeStreams.size} active streams...`);
    
    // Stop all active streams
    for (const [id, stream] of activeStreams.entries()) {
        console.log(`üõë [Stream ${id}] Shutting down...`);
        try {
            if (stream.interval) {
                clearInterval(stream.interval);
            }
            
            // Close file watcher
            if (stream.fileWatcher) {
                stream.fileWatcher.close();
                console.log(`‚úÖ [Stream ${id}] File watcher closed`);
            }
            
            if (stream.recorder) {
                await stream.recorder.stop();
            }
            
            if (stream.browser) {
                await stream.browser.close();
            }
        } catch (error) {
            console.error(`‚ùå [Stream ${id}] Shutdown error:`, error);
        }
    }
    
    activeStreams.clear();
    console.log('‚úÖ All streams cleaned up');
    process.exit(0);
});
