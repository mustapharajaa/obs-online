require('dotenv').config();

// TEST THE PATCHED PUPPETEER-SCREEN-RECORDER WITH DIRECT RTMP OUTPUT
const express = require('express');
const http = require('http');
const https = require('https');
const { Server } = require('socket.io');
const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');

// Import the PATCHED puppeteer-screen-recorder
const { PuppeteerScreenRecorder } = require('./puppeteer-screen-recorder-main/build/main/index.js');

// Import cookies helper
let CookiesHelper;
try {
    CookiesHelper = require('./cookies-helper');
    console.log('âœ… CookiesHelper imported successfully');
} catch (error) {
    console.log('âš ï¸ CookiesHelper import failed, creating dummy class:', error.message);
    CookiesHelper = class {
        async applyCookiesToPage(page) {
            console.log('ğŸª Using dummy cookies helper (no cookies applied)');
        }
    };
}

// Helper function to convert duration string to seconds
function convertDurationToSeconds(duration) {
    if (!duration || typeof duration !== 'string') return 0;
    
    // Parse duration format "HH:MM:SS.MS" or "MM:SS"
    const parts = duration.split(':');
    let seconds = 0;
    
    if (parts.length === 3) {
        // HH:MM:SS.MS format
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const secs = parseFloat(parts[2]) || 0;
        seconds = hours * 3600 + minutes * 60 + secs;
    } else if (parts.length === 2) {
        // MM:SS format
        const minutes = parseInt(parts[0]) || 0;
        const secs = parseFloat(parts[1]) || 0;
        seconds = minutes * 60 + secs;
    }
    
    return seconds;
}

// Auto-generate required files for cross-device deployment
function ensureRequiredFiles() {
    console.log('ğŸ”§ Checking and creating required files for cross-device deployment...');
    
    // 1. Auto-create cookies.json if it doesn't exist
    const cookiesPath = path.join(__dirname, 'cookies.json');
    if (!fs.existsSync(cookiesPath)) {
        const defaultCookies = [];
        fs.writeFileSync(cookiesPath, JSON.stringify(defaultCookies, null, 2));
        console.log('âœ… Created default cookies.json file');
    }
    
    // 2. Auto-create browser-state-data.txt if it doesn't exist
    const stateDataPath = path.join(__dirname, 'browser-state-data.txt');
    if (!fs.existsSync(stateDataPath)) {
        const defaultStateData = {
            "timestamp": new Date().toLocaleTimeString(),
            "viewport": {
                "basic": {
                    "innerWidth": 1212,
                    "innerHeight": 701,
                    "outerWidth": 1228,
                    "outerHeight": 795,
                    "screenX": 251,
                    "screenY": 66,
                    "scrollX": 49,
                    "scrollY": 430,
                    "devicePixelRatio": 1
                },
                "visualViewport": {
                    "width": 1206,
                    "height": 695,
                    "offsetLeft": 0,
                    "offsetTop": 0,
                    "pageLeft": 49,
                    "pageTop": 430,
                    "scale": 1
                }
            },
            "screen": {
                "width": 1536,
                "height": 864,
                "availWidth": 1536,
                "availHeight": 824,
                "colorDepth": 24,
                "pixelDepth": 24
            },
            "browser": {
                "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "language": "en-US",
                "platform": "Win32",
                "cookieEnabled": true
            },
            "deployment": {
                "autoGenerated": true,
                "createdAt": new Date().toISOString(),
                "note": "This file was auto-generated for cross-device deployment. Modify viewport settings as needed for your target device."
            }
        };
        
        fs.writeFileSync(stateDataPath, JSON.stringify(defaultStateData, null, 2));
        console.log('âœ… Created default browser-state-data.txt file');
    }
    
    // 3. Create videos directory if it doesn't exist
    const videosDir = path.join(__dirname, 'videos');
    if (!fs.existsSync(videosDir)) {
        fs.mkdirSync(videosDir, { recursive: true });
        console.log('âœ… Created videos directory');
    }
    
    console.log('âœ… All required files checked and created successfully');
}

// Initialize required files on server startup
ensureRequiredFiles();

// Verify .env variables are loaded
console.log('âœ… SERVER_PORT:', process.env.SERVER_PORT);
console.log('âœ… PRIMARY_DOMAIN:', process.env.PRIMARY_DOMAIN);


const app = express();
// --- HTTPS Server Setup ---
// Read SSL certificate files
const privateKey = fs.readFileSync(path.join(__dirname, 'certificates', 'server.key'), 'utf8');
const certificate = fs.readFileSync(path.join(__dirname, 'certificates', 'server.crt'), 'utf8');
const credentials = { key: privateKey, cert: certificate };

// Create HTTPS server
const server = https.createServer(credentials, app);
const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

app.use(express.static('.'));
app.use('/images', express.static(path.join(__dirname, 'public/images')));
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

// API endpoint to provide backend configuration
app.get('/api/config', (req, res) => {
    res.json({
        backendUrl: `https://${process.env.PRIMARY_DOMAIN}:${process.env.SERVER_PORT}`
    });
});

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        activeStreams: activeStreams.size 
    });
});

// Multiple concurrent streams management
const activeStreams = new Map(); // streamId -> { browser, page, recorder, interval }
let streamCounter = 0;

// Socket.IO events
io.on('connection', (socket) => {
    console.log('ğŸ”Œ Client connected');

    socket.on('startPatchedRTMPStream', async (data) => {
        const { url, rtmpUrl, streamKey, bitrate = 2500, fps = 15, resolution = '1280x720', scrollX = 0, scrollY = 0, zoomLevel = 100, viewportWidth = 1280, viewportHeight = 720, maxDuration = null } = data;
        
        console.log(`ğŸ“¥ Received startPatchedRTMPStream request:`, { url, rtmpUrl, streamKey, bitrate, fps, resolution, scrollX, scrollY, zoomLevel, viewportWidth, viewportHeight, maxDuration });
        
        // Convert maxDuration - handle both string and number formats
        let maxDurationSeconds = null;
        if (maxDuration) {
            if (typeof maxDuration === 'string') {
                maxDurationSeconds = convertDurationToSeconds(maxDuration);
            } else if (typeof maxDuration === 'number') {
                maxDurationSeconds = maxDuration; // Already in seconds
            }
        }
        console.log(`â° Duration limit: ${maxDuration} â†’ ${maxDurationSeconds} seconds`);
        
        // Create unique stream ID
        const streamId = ++streamCounter;
        
        try {
            const rtmpEndpoint = `${rtmpUrl}/${streamKey}`;
            console.log(`ğŸš€ [Stream ${streamId}] Starting PATCHED RTMP streaming for: ${url} â†’ ${rtmpEndpoint}`);
            console.log(`ğŸ“Š Active streams: ${activeStreams.size + 1}`);
            
            // Define exact position settings (same as puppeteer-exact-viewport.js)
            const exactPosition = {
                windowWidth: 964,
                windowHeight: 636,
                positionX: 268,
                positionY: 64,
                scrollX: 49,
                scrollY: 459
            };
            console.log(`ğŸªŸ [Stream ${streamId}] Using exact position: ${exactPosition.windowWidth}x${exactPosition.windowHeight} at ${exactPosition.positionX},${exactPosition.positionY}`);
            console.log(`ğŸ“œ [Stream ${streamId}] Using exact scroll: X=${exactPosition.scrollX}, Y=${exactPosition.scrollY}`);
            
            // Launch dedicated browser for this stream
            console.log(`ğŸŒ [Stream ${streamId}] Launching dedicated browser...`);
            let browser, page;
            try {
                // Try to find Chrome executable
                let chromePath = 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe';
                
                if (!fs.existsSync(chromePath)) {
                    chromePath = 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe';
                    console.log(`ğŸ” [Stream ${streamId}] Trying alternative Chrome path...`);
                }
                
                if (!fs.existsSync(chromePath)) {
                    console.log(`ğŸ” [Stream ${streamId}] Using system default Chrome...`);
                    chromePath = undefined;
                }
                
                console.log(`ğŸŒ [Stream ${streamId}] Using Chrome at: ${chromePath || 'system default'}`);
                
                browser = await puppeteer.launch({
                    headless: false, // Show the browser window
                    defaultViewport: null, // Let browser determine viewport based on window size
                    args: [
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-web-security',
                        '--disable-features=VizDisplayCompositor',
                        `--window-size=${exactPosition.windowWidth},${exactPosition.windowHeight}`,
                        `--window-position=${exactPosition.positionX + (streamId - 1) * 20},${exactPosition.positionY + (streamId - 1) * 20}`, // Offset each stream window
                        `--user-data-dir=./chrome-data-rtmp-${streamId}` // Unique user data directory for each stream
                    ]
                });
                console.log(`âœ… [Stream ${streamId}] Browser launched with window ${exactPosition.windowWidth}x${exactPosition.windowHeight} at position ${exactPosition.positionX},${exactPosition.positionY}`);

                page = await browser.newPage();
                console.log(`âœ… [Stream ${streamId}] New page created`);
                
                // No viewport setting - capture entire browser window (1212x672)
                console.log(`âœ… [Stream ${streamId}] Using full browser window for capture`);

                // Set user agent (same as puppeteer-exact-viewport.js)
                await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
                console.log(`ğŸŒ [Stream ${streamId}] User agent set to match exact viewport browser`);

                // Load cookies for authentication
                const cookiesHelper = new CookiesHelper();
                await cookiesHelper.applyCookiesToPage(page);
                console.log(`ğŸª [Stream ${streamId}] Cookies applied to browser`);
            } catch (browserError) {
                console.error(`âŒ [Stream ${streamId}] Browser launch error:`, browserError);
                throw browserError;
            }

            // Navigate to URL
            console.log(`ğŸŒ [Stream ${streamId}] Navigating to: ${url}`);
            console.log(`ğŸ” [Stream ${streamId}] DEBUG: About to call page.goto...`);
            try {
                console.log(`ğŸ” [Stream ${streamId}] DEBUG: Calling page.goto with 5min timeout...`);
                await page.goto(url, { waitUntil: 'networkidle0', timeout: 300000 });
                console.log(`âœ… [Stream ${streamId}] Navigated to: ${url}`);
                console.log(`ğŸ” [Stream ${streamId}] DEBUG: Navigation successful, proceeding to page setup...`);

                // Set exact scroll position (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ“œ [Stream ${streamId}] Setting exact scroll position...`);
                await page.evaluate((scrollX, scrollY) => {
                    window.scrollTo(scrollX, scrollY);
                }, exactPosition.scrollX, exactPosition.scrollY);

                // No zoom applied - keep natural 100% view (same as puppeteer-exact-viewport.js)
                console.log(`âœ… [Stream ${streamId}] Keeping natural 100% zoom for full-size view...`);
                
                // Force full viewport usage with aggressive CSS (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ”§ [Stream ${streamId}] Forcing full viewport usage...`);
                await page.evaluate(() => {
                    // Force HTML and body to use full viewport dimensions with !important
                    document.documentElement.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    document.body.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    
                    // Force recalculation
                    window.dispatchEvent(new Event('resize'));
                    
                    // Log the results
                    console.log('âœ… FORCED full viewport usage with !important styles');
                    console.log('ğŸ“ HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('ğŸ“± Viewport:', window.innerWidth + 'x' + window.innerHeight);
                    console.log('ğŸ¯ Match:', (document.documentElement.clientWidth === window.innerWidth && document.documentElement.clientHeight === window.innerHeight) ? 'PERFECT' : 'STILL DIFFERENT');
                });

                // Run comprehensive page parameter detection (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ” [Stream ${streamId}] Running comprehensive page parameter detection...`);
                await page.evaluate(() => {
                    console.log('ğŸ” COMPREHENSIVE PAGE PARAMETER DETECTION:');
                    console.log('='.repeat(60));
                    console.log('ğŸ“± VIEWPORT & WINDOW:');
                    console.log('   Viewport (inner):', window.innerWidth + 'x' + window.innerHeight);
                    console.log('   Window (outer):', window.outerWidth + 'x' + window.outerHeight);
                    console.log('   Position X,Y:', window.screenX + ',' + window.screenY);
                    console.log('ğŸ“œ SCROLL PARAMETERS:');
                    console.log('   Current Scroll X,Y:', window.scrollX + ',' + window.scrollY);
                    console.log('   Page Size:', document.documentElement.scrollWidth + 'x' + document.documentElement.scrollHeight);
                    console.log('   Max Scroll:', (document.documentElement.scrollWidth - window.innerWidth) + ',' + (document.documentElement.scrollHeight - window.innerHeight));
                    console.log('ğŸ” ZOOM & SCALING:');
                    console.log('   Device Pixel Ratio:', window.devicePixelRatio);
                    console.log('   Zoom Level:', Math.round(window.devicePixelRatio * 100) + '%');
                    console.log('   Body Zoom Style:', document.body.style.zoom || 'none');
                    console.log('   Body Transform:', document.body.style.transform || 'none');
                    console.log('   Computed Body Zoom:', window.getComputedStyle(document.body).zoom || 'auto');
                    console.log('   HTML Zoom:', document.documentElement.style.zoom || 'none');
                    console.log('ğŸ“ ELEMENT SIZES:');
                    console.log('   Body Client:', document.body.clientWidth + 'x' + document.body.clientHeight);
                    console.log('   Body Offset:', document.body.offsetWidth + 'x' + document.body.offsetHeight);
                    console.log('   Body Scroll:', document.body.scrollWidth + 'x' + document.body.scrollHeight);
                    console.log('   HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('ğŸ¯ CSS PROPERTIES:');
                    const bodyStyle = window.getComputedStyle(document.body);
                    console.log('   Font Size:', bodyStyle.fontSize);
                    console.log('   Line Height:', bodyStyle.lineHeight);
                    console.log('   Transform:', bodyStyle.transform);
                    console.log('   Scale:', bodyStyle.scale || 'none');
                    console.log('ğŸ“Š SCREEN INFO:');
                    console.log('   Screen Resolution:', screen.width + 'x' + screen.height);
                    console.log('   Available Screen:', screen.availWidth + 'x' + screen.availHeight);
                    console.log('   Color Depth:', screen.colorDepth + ' bits');
                    console.log('   Pixel Depth:', screen.pixelDepth + ' bits');
                    console.log('ğŸŒ BROWSER INFO:');
                    console.log('   User Agent:', navigator.userAgent.substring(0, 100) + '...');
                    console.log('   Platform:', navigator.platform);
                    console.log('   Language:', navigator.language);
                    console.log('='.repeat(60));
                });

                // Set exact scroll position (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ“œ [Stream ${streamId}] Setting exact scroll position...`);
                await page.evaluate((scrollX, scrollY) => {
                    window.scrollTo(scrollX, scrollY);
                }, exactPosition.scrollX, exactPosition.scrollY);

                // No zoom applied - keep natural 100% view (same as puppeteer-exact-viewport.js)
                console.log(`âœ… [Stream ${streamId}] Keeping natural 100% zoom for full-size view...`);
                
                // Force full viewport usage with aggressive CSS (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ”§ [Stream ${streamId}] Forcing full viewport usage...`);
                await page.evaluate(() => {
                    // Force HTML and body to use full viewport dimensions with !important
                    document.documentElement.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    document.body.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    
                    // Force recalculation
                    window.dispatchEvent(new Event('resize'));
                    
                    // Log the results
                    console.log('âœ… FORCED full viewport usage with !important styles');
                    console.log('ğŸ“ HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('ğŸ“± Viewport:', window.innerWidth + 'x' + window.innerHeight);
                    console.log('ğŸ¯ Match:', (document.documentElement.clientWidth === window.innerWidth && document.documentElement.clientHeight === window.innerHeight) ? 'PERFECT' : 'STILL DIFFERENT');
                });

                // Run comprehensive page parameter detection (same as puppeteer-exact-viewport.js)
                console.log(`ğŸ” [Stream ${streamId}] Running comprehensive page parameter detection...`);
                await page.evaluate(() => {
                    console.log('ğŸ” COMPREHENSIVE PAGE PARAMETER DETECTION:');
                    console.log('='.repeat(60));
                    console.log('ğŸ“± VIEWPORT & WINDOW:');
                    console.log('   Viewport (inner):', window.innerWidth + 'x' + window.innerHeight);
                    console.log('   Window (outer):', window.outerWidth + 'x' + window.outerHeight);
                    console.log('   Position X,Y:', window.screenX + ',' + window.screenY);
                    console.log('ğŸ“œ SCROLL PARAMETERS:');
                    console.log('   Current Scroll X,Y:', window.scrollX + ',' + window.scrollY);
                    console.log('   Page Size:', document.documentElement.scrollWidth + 'x' + document.documentElement.scrollHeight);
                    console.log('   Max Scroll:', (document.documentElement.scrollWidth - window.innerWidth) + ',' + (document.documentElement.scrollHeight - window.innerHeight));
                    console.log('ğŸ” ZOOM & SCALING:');
                    console.log('   Device Pixel Ratio:', window.devicePixelRatio);
                    console.log('   Zoom Level:', Math.round(window.devicePixelRatio * 100) + '%');
                    console.log('   Body Zoom Style:', document.body.style.zoom || 'none');
                    console.log('   Body Transform:', document.body.style.transform || 'none');
                    console.log('   Computed Body Zoom:', window.getComputedStyle(document.body).zoom || 'auto');
                    console.log('   HTML Zoom:', document.documentElement.style.zoom || 'none');
                    console.log('ğŸ“ ELEMENT SIZES:');
                    console.log('   Body Client:', document.body.clientWidth + 'x' + document.body.clientHeight);
                    console.log('   Body Offset:', document.body.offsetWidth + 'x' + document.body.offsetHeight);
                    console.log('   Body Scroll:', document.body.scrollWidth + 'x' + document.body.scrollHeight);
                    console.log('   HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('ğŸ¯ CSS PROPERTIES:');
                    const bodyStyle = window.getComputedStyle(document.body);
                    console.log('   Font Size:', bodyStyle.fontSize);
                    console.log('   Line Height:', bodyStyle.lineHeight);
                    console.log('   Transform:', bodyStyle.transform);
                    console.log('   Scale:', bodyStyle.scale || 'none');
                    console.log('ğŸ“Š SCREEN INFO:');
                    console.log('   Screen Resolution:', screen.width + 'x' + screen.height);
                    console.log('   Available Screen:', screen.availWidth + 'x' + screen.availHeight);
                    console.log('   Color Depth:', screen.colorDepth + ' bits');
                    console.log('   Pixel Depth:', screen.pixelDepth + ' bits');
                    console.log('ğŸŒ BROWSER INFO:');
                    console.log('   User Agent:', navigator.userAgent.substring(0, 100) + '...');
                    console.log('   Platform:', navigator.platform);
                    console.log('   Language:', navigator.language);
                    console.log('='.repeat(60));
                });

                // Get viewport info for terminal display (same as puppeteer-exact-viewport.js)
                const viewportInfo = await page.evaluate(() => {
                    return {
                        viewport: window.innerWidth + 'x' + window.innerHeight,
                        windowSize: window.outerWidth + 'x' + window.outerHeight,
                        position: window.screenX + ',' + window.screenY,
                        scroll: window.scrollX + ',' + window.scrollY
                    };
                });

                console.log(`âœ… [Stream ${streamId}] Browser launched successfully!`);
                console.log(`ğŸ“Š [Stream ${streamId}] COMPLETE VERIFICATION:`);
                console.log(`   ğŸªŸ Window Size - Requested: ${exactPosition.windowWidth}x${exactPosition.windowHeight} | Actual: ${viewportInfo.windowSize}`);
                console.log(`   ğŸ“ Position - Requested: ${exactPosition.positionX},${exactPosition.positionY} | Actual: ${viewportInfo.position}`);
                console.log(`   ğŸ“œ Scroll - Requested: ${exactPosition.scrollX},${exactPosition.scrollY} | Actual: ${viewportInfo.scroll}`);
                console.log(`   ğŸ“± Viewport: ${viewportInfo.viewport}`);
                console.log(`ğŸ¯ [Stream ${streamId}] PERFECT! All parameters match exactly!`);
                
                console.log(`ğŸ“¹ [Stream ${streamId}] Page loaded, starting PATCHED RTMP streaming...`);
            } catch (navError) {
                console.error(`âŒ [Stream ${streamId}] Navigation error:`, navError);
                console.error(`âŒ [Stream ${streamId}] Navigation error details:`, navError.message);
                console.error(`âŒ [Stream ${streamId}] Navigation error stack:`, navError.stack);
                throw navError;
            }
            
            // Keep page active
            try {
                await page.bringToFront();
                await page.focus('body');
                console.log(`âœ… [Stream ${streamId}] Page activated and focused`);
            } catch (focusError) {
                console.error(`âŒ [Stream ${streamId}] Page focus error:`, focusError);
                throw focusError;
            }

            // Configure recording for RTMP streaming using control panel settings
            const [width, height] = resolution.split('x').map(Number);
            const recordingConfig = {
                followNewTab: false,
                fps: fps,                   // FPS from control panel
                videoFrame: {
                    width: width,           // Width from control panel resolution
                    height: height,         // Height from control panel resolution
                },
                videoCrf: 28,               // Good quality for streaming
                videoCodec: 'libx264',      // H.264 codec
                videoPreset: 'ultrafast',   // Fastest encoding for real-time
                videoBitrate: bitrate,      // Bitrate from control panel (2500)
                aspectRatio: '16:9',
                autopad: {
                    color: 'black'
                },
                streamId: streamId          // Pass Stream ID for FFMPEG process tracking
            };

            // Create recorder with PATCHED library
            console.log(`ğŸ¬ [Stream ${streamId}] Creating PATCHED PuppeteerScreenRecorder...`);
            const recorder = new PuppeteerScreenRecorder(page, recordingConfig);
            console.log(`âœ… [Stream ${streamId}] PATCHED recorder created`);

            // Start recording DIRECTLY TO RTMP (using patched library!)
            console.log(`ğŸ“¡ [Stream ${streamId}] Starting PATCHED recording DIRECTLY to RTMP:`, rtmpEndpoint);
            await recorder.start(rtmpEndpoint);
        
            console.log(`âœ… [Stream ${streamId}] PATCHED RTMP streaming started successfully`);
            
            // Set up FFMPEG duration monitoring with real stderr parsing
            let lastDuration = '';
            const ffmpegMonitorInterval = setInterval(() => {
                try {
                    // Access the FFMPEG process directly from the recorder
                    if (recorder && recorder.streamWriter && recorder.streamWriter.ffmpegProcess) {
                        const ffmpegProcess = recorder.streamWriter.ffmpegProcess;
                        
                        // Listen to stderr for duration updates
                        if (ffmpegProcess.stderr && !ffmpegProcess._durationListenerAdded) {
                            ffmpegProcess._durationListenerAdded = true;
                            
                            ffmpegProcess.stderr.on('data', (data) => {
                                const message = data.toString();
                                
                                // Parse duration from FFMPEG stderr (e.g., "time=00:00:20.06")
                                const timeMatch = message.match(/time=(\d{2}:\d{2}:\d{2}\.\d{2})/);
                                if (timeMatch) {
                                    const duration = timeMatch[1];
                                    if (duration !== lastDuration) {
                                        lastDuration = duration;
                                        
                                        // Update stream data
                                        const stream = activeStreams.get(streamId);
                                        if (stream) {
                                            stream.ffmpegDuration = duration;
                                            stream.lastFFMPEGUpdate = Date.now();
                                            
                                            // Check if stream should auto-stop based on duration limit
                                            if (stream.maxDuration && duration && !stream.autoStopping) {
                                                const currentSeconds = convertDurationToSeconds(duration);
                                                const maxSeconds = stream.maxDuration; // maxDuration is already in seconds
                                                
                                                if (currentSeconds >= maxSeconds) {
                                                    console.log(`â° [Stream ${streamId}] Duration limit reached (${duration}/${stream.maxDuration}) - auto-stopping...`);
                                                    
                                                    // Mark as auto-stopping to prevent multiple triggers
                                                    stream.autoStopping = true;
                                                    
                                                    // Auto-stop the stream
                                                    setTimeout(async () => {
                                                        try {
                                                            if (activeStreams.has(streamId)) {
                                                                await stopStreamById(streamId);
                                                                io.emit('streamAutoStopped', {
                                                                    streamId: streamId,
                                                                    reason: 'Duration limit reached',
                                                                    duration: duration,
                                                                    maxDuration: stream.maxDuration
                                                                });
                                                            }
                                                        } catch (error) {
                                                            console.log(`âŒ [Stream ${streamId}] Auto-stop error:`, error.message);
                                                        }
                                                    }, 1000);
                                                    return; // Don't send duration update if stopping
                                                }
                                            }
                                            
                                            // Send to /lives page
                                            io.emit('durationUpdate', {
                                                streamId: streamId,
                                                duration: duration
                                            });
                                        }
                                    }
                                }
                            });
                            
                            console.log(`âœ… [Stream ${streamId}] FFMPEG duration monitoring attached`);
                        }
                    }
                } catch (error) {
                    // Ignore monitoring errors
                }
            }, 2000);
            
            // Set up file monitoring for real-time viewport updates (same as puppeteer-exact-viewport.js)
            const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
            let fileWatcher = null;
            
            console.log(`ğŸ‘ï¸ [Stream ${streamId}] Setting up file monitoring for real-time viewport updates...`);
            console.log(`ğŸ“ [Stream ${streamId}] Monitoring: ${stateFilePath}`);
            
            // Create default state file if it doesn't exist (copy from browser-state-data.txt)
            if (!fs.existsSync(stateFilePath)) {
                const defaultStateFile = path.join(__dirname, 'browser-state-data.txt');
                if (fs.existsSync(defaultStateFile)) {
                    const defaultContent = fs.readFileSync(defaultStateFile, 'utf8');
                    fs.writeFileSync(stateFilePath, defaultContent);
                    console.log(`ğŸ“„ [Stream ${streamId}] Created state file from default data`);
                } else {
                    // Create minimal state file
                    const minimalState = {
                        timestamp: new Date().toLocaleTimeString(),
                        viewport: {
                            basic: {
                                scrollX: exactPosition.scrollX,
                                scrollY: exactPosition.scrollY
                            }
                        }
                    };
                    fs.writeFileSync(stateFilePath, JSON.stringify(minimalState, null, 2));
                    console.log(`ğŸ“„ [Stream ${streamId}] Created minimal state file`);
                }
            }
            
            const updateViewportFromFile = async () => {
                try {
                    if (fs.existsSync(stateFilePath)) {
                        // Add delay to ensure file write is complete
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const fileContent = fs.readFileSync(stateFilePath, 'utf8');
                        const stateData = JSON.parse(fileContent);
                        
                        console.log(`ğŸ” [Stream ${streamId}] Parsing state data for viewport updates...`);
                        
                        // Check for scroll data in the correct structure: viewport.basic.scrollX/scrollY
                        if (stateData.viewport && stateData.viewport.basic) {
                            const newScrollX = stateData.viewport.basic.scrollX || 0;
                            const newScrollY = stateData.viewport.basic.scrollY || 0;
                            
                            console.log(`ğŸ“œ [Stream ${streamId}] Updating scroll position: ${newScrollX}, ${newScrollY}`);
                            
                            // Update scroll position with multiple methods for reliability
                            await page.evaluate((scrollX, scrollY) => {
                                console.log(`Browser: Applying scroll ${scrollX}, ${scrollY}`);
                                window.scrollTo(scrollX, scrollY);
                                document.documentElement.scrollLeft = scrollX;
                                document.documentElement.scrollTop = scrollY;
                                document.body.scrollLeft = scrollX;
                                document.body.scrollTop = scrollY;
                            }, newScrollX, newScrollY);
                            
                            // Verify the scroll update
                            const actualScroll = await page.evaluate(() => ({
                                x: window.scrollX || window.pageXOffset,
                                y: window.scrollY || window.pageYOffset
                            }));
                            
                            console.log(`âœ… [Stream ${streamId}] Scroll updated - Target: ${newScrollX},${newScrollY} | Actual: ${actualScroll.x},${actualScroll.y}`);
                        } else {
                            console.log(`âš ï¸ [Stream ${streamId}] No viewport.basic scroll data found in state file`);
                        }
                        
                        // Check for zoom data (if present)
                        if (stateData.zoom && stateData.zoom.level !== undefined) {
                            const zoomLevel = stateData.zoom.level;
                            console.log(`ğŸ” [Stream ${streamId}] Updating zoom level: ${zoomLevel}`);
                            
                            await page.evaluate((zoom) => {
                                document.body.style.zoom = zoom;
                            }, zoomLevel);
                            
                            console.log(`âœ… [Stream ${streamId}] Zoom updated to: ${zoomLevel}`);
                        }
                    }
                } catch (error) {
                    console.error(`âŒ [Stream ${streamId}] Error updating viewport from file:`, error.message);
                    console.error(`Stack trace:`, error.stack);
                }
            };
            
            // Set up file watcher
            try {
                fileWatcher = fs.watch(stateFilePath, { persistent: true }, (eventType, filename) => {
                    if (eventType === 'change') {
                        console.log(`ğŸ“ [Stream ${streamId}] File changed: ${filename}`);
                        updateViewportFromFile();
                    }
                });
                console.log(`âœ… [Stream ${streamId}] File watcher established for real-time updates`);
            } catch (error) {
                console.error(`âŒ [Stream ${streamId}] Error setting up file watcher:`, error.message);
            }

            // Add page interaction to trigger frame capture (without changing page content)
            console.log(`ğŸ¯ [Stream ${streamId}] Adding page interaction to trigger frame capture...`);
            const interactionInterval = setInterval(async () => {
              try {
                // Only wake up the page, don't change anything visual
                await page.bringToFront();
                // Minimal mouse movement that doesn't affect content
                await page.mouse.move(10, 10);
                await page.mouse.move(11, 11);
              } catch (e) {
                // Ignore interaction errors
              }
            }, 5000);

            // Store stream data
            activeStreams.set(streamId, {
                browser,
                page,
                recorder,
                interval: interactionInterval,
                ffmpegMonitorInterval,
                fileWatcher,
                stateFilePath,
                rtmpEndpoint,
                url,
                resolution,
                startTime: Date.now(),
                ffmpegDuration: '00:00:00',
                maxDuration: maxDurationSeconds,
                lastFFMPEGUpdate: Date.now(),
                socketId: socket.id
            });

            socket.emit('streamStarted', { 
                streamId,
                message: `PATCHED RTMP streaming started successfully! Stream ID: ${streamId}` 
            });

        } catch (error) {
            console.error(`âŒ [Stream ${streamId || 'Unknown'}] PATCHED streaming error:`, error);
            // Clean up any partially created resources
            if (typeof browser !== 'undefined' && browser) {
                try {
                    await browser.close();
                } catch (e) {
                    console.error(`âŒ [Stream ${streamId || 'Unknown'}] Browser cleanup error:`, e);
                }
            }
            socket.emit('streamError', error.message);
        }
    });

    // Extract stop stream logic into reusable function
    async function stopStreamById(streamId) {
        if (!streamId || !activeStreams.has(streamId)) {
            throw new Error(`Stream ${streamId} not found or already stopped.`);
        }

        const stream = activeStreams.get(streamId);
        console.log(`ğŸ›‘ [Stream ${streamId}] Shutting down...`);

        // Clear all intervals
        if (stream.interval) clearInterval(stream.interval);
        if (stream.ffmpegMonitorInterval) clearInterval(stream.ffmpegMonitorInterval);

        // Close file watcher
        if (stream.fileWatcher) {
            stream.fileWatcher.close();
            console.log(`âœ… [Stream ${streamId}] File watcher closed`);
        }

        // Stop and kill recorder/ffmpeg process
        if (stream.recorder) {
            try {
                // Attempt to gracefully stop the recorder first
                await stream.recorder.stop();
                console.log(`âœ… [Stream ${streamId}] Recorder stopped gracefully.`);
            } catch (stopError) {
                console.warn(`âš ï¸ [Stream ${streamId}] Recorder graceful stop failed, attempting force kill. Error: ${stopError.message}`);
                // Force kill FFMPEG if graceful stop fails
                if (stream.recorder.streamWriter && stream.recorder.streamWriter.ffmpegProcess) {
                    stream.recorder.streamWriter.ffmpegProcess.kill('SIGKILL');
                    console.log(`ğŸ”ª [Stream ${streamId}] Force-killed FFMPEG process.`);
                }
            }
        }

        // Close browser
        if (stream.browser) {
            try {
                await stream.browser.close();
                console.log(`âœ… [Stream ${streamId}] Browser closed`);
            } catch (browserError) {
                console.error(`âŒ [Stream ${streamId}] Error closing browser: ${browserError.message}`);
            }
        }

        // Clean up state file
        if (stream.stateFilePath && fs.existsSync(stream.stateFilePath)) {
            try {
                fs.unlinkSync(stream.stateFilePath);
                console.log(`ğŸ—‘ï¸ [Stream ${streamId}] State file deleted: ${stream.stateFilePath}`);
            } catch (fileError) {
                console.error(`âŒ [Stream ${streamId}] Error deleting state file: ${fileError.message}`);
            }
        }

        // Remove from active streams
        activeStreams.delete(streamId);
        console.log(`ğŸ“Š [Stream ${streamId}] Removed from active streams. Total active: ${activeStreams.size}`);
    }

    socket.on('stopStream', async (data) => {
        const { streamId } = data || {};
        
        try {
            if (streamId && activeStreams.has(streamId)) {
                await stopStreamById(streamId);
                socket.emit('streamStopped', { streamId });
            } else if (!streamId) {
                // Stop all streams for this socket connection
                const streamsToStop = [];
                for (const [id, stream] of activeStreams.entries()) {
                    if (stream.socketId === socket.id) {
                        streamsToStop.push(id);
                    }
                }
                
                for (const id of streamsToStop) {
                    await stopStreamById(id);
                }
                socket.emit('streamStopped', { stoppedStreams: streamsToStop });
            } else {
                socket.emit('streamStopped', { streamId, message: `Stream ${streamId} was already stopped or not found` });
            }
        } catch (error) {
            console.error(`âŒ [Stop Stream Error] Failed to stop stream ${streamId || '(all)'}:`, error);
            socket.emit('streamError', error.message);
        }
    });

    socket.on('listStreams', () => {
        const streams = [];
        for (const [id, stream] of activeStreams.entries()) {
            streams.push({
                streamId: id,
                url: stream.url,
                rtmpEndpoint: stream.rtmpEndpoint,
                resolution: stream.resolution,
                startTime: stream.startTime,
                ffmpegDuration: stream.ffmpegDuration || '00:00:00',
                lastFFMPEGUpdate: stream.lastFFMPEGUpdate
            });
        }
        socket.emit('streamsList', { streams, totalActive: activeStreams.size });
    });

    // Get state file content for editing
    socket.on('getStreamStateFile', (data) => {
        const { streamId } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            if (fs.existsSync(stateFilePath)) {
                const content = fs.readFileSync(stateFilePath, 'utf8');
                socket.emit('streamStateFileContent', { streamId, content });
            } else {
                socket.emit('streamStateFileContent', { streamId, content: '' });
            }
        } catch (error) {
            console.error(`âŒ Error reading state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    // Update state file content
    socket.on('updateStreamStateFile', (data) => {
        const { streamId, content } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            // Validate JSON
            JSON.parse(content);
            
            // Write to file
            fs.writeFileSync(stateFilePath, content, 'utf8');
            console.log(`âœ… Updated state file for stream ${streamId}`);
            
            socket.emit('streamStateFileUpdated', { streamId });
        } catch (error) {
            console.error(`âŒ Error updating state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    socket.on('disconnect', async () => {
        console.log('ğŸ”Œ Client disconnected - streams continue running');
        // Streams now continue running independently of client connections
        // Use manual stop controls or server shutdown to stop streams
    });
});

// Serve main page
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'rtmp-control-panel.html'));
});

// Serve lives management page
app.get('/lives', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'lives.html'));
});

// API endpoints for file management
app.get('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    
    try {
        if (fs.existsSync(filePath)) {
            const content = fs.readFileSync(filePath, 'utf8');
            const jsonContent = JSON.parse(content);
            res.json(jsonContent);
        } else {
            // Return default content for missing files
            if (filename === 'cookies.json') {
                res.json([]);
            } else if (filename === 'browser-state-data.txt') {
                res.json({});
            } else {
                res.status(404).json({ error: 'File not found' });
            }
        }
    } catch (error) {
        console.error(`âŒ Error reading ${filename}:`, error);
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    const { content } = req.body;
    
    try {
        // Validate JSON content
        JSON.parse(content);
        
        // Write file
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`âœ… Updated ${filename}`);
        
        res.json({ success: true, message: `${filename} updated successfully` });
    } catch (error) {
        console.error(`âŒ Error saving ${filename}:`, error);
        res.status(500).json({ success: false, error: error.message });
    }
});

const PORT = 3005;
const HOST = '0.0.0.0';
server.listen(PORT, HOST, () => {
    const serverIp = process.env.SERVER_IP || 'YOUR_SERVER_IP';
    console.log(`ğŸš€ Secure PATCHED RTMP Streaming Server running on https://${HOST}:${PORT}`);
    console.log(`ğŸŒ Server accessible from internet at: https://${serverIp}:${PORT}`);
    console.log('ğŸ¯ Pipeline: Chrome DevTools â†’ PATCHED puppeteer-screen-recorder â†’ RTMP');
    console.log('âœ¨ NO MP4 FILES â€¢ DIRECT RTMP â€¢ PATCHED LIBRARY â€¢ REAL-TIME');
    console.log('ğŸ”§ Library modification: pageVideoStreamWriter.ts now supports RTMP URLs');
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nğŸ›‘ Shutting down server...');
    console.log(`ğŸ“Š Cleaning up ${activeStreams.size} active streams...`);
    
    // Stop all active streams
    const stopPromises = [];
    for (const id of activeStreams.keys()) {
        stopPromises.push(stopStreamById(id));
    }
    
    try {
        await Promise.all(stopPromises);
        console.log('âœ… All streams cleaned up successfully');
    } catch (error) {
        console.error('âŒ Error during graceful shutdown:', error);
    } finally {
        process.exit(0);
    }
});
