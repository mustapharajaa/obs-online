require('dotenv').config();

// Disable SSL certificate verification for self-signed certificates
process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = 0;

// TEST THE PATCHED PUPPETEER-SCREEN-RECORDER WITH DIRECT RTMP OUTPUT
const express = require('express');
const http = require('http');
const https = require('https');
const { Server } = require('socket.io');
const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');

// Import the PATCHED puppeteer-screen-recorder
const { PuppeteerScreenRecorder } = require('./puppeteer-screen-recorder-main/build/main/index.js');

// Import cookies helper
let CookiesHelper;
try {
    CookiesHelper = require('./cookies-helper');
    console.log('‚úÖ CookiesHelper imported successfully');
} catch (error) {
    console.log('‚ö†Ô∏è CookiesHelper import failed, creating dummy class:', error.message);
    CookiesHelper = class {
        async applyCookiesToPage(page) {
            console.log('üç™ Using dummy cookies helper (no cookies applied)');
        }
    };
}

// Helper function to convert duration string to seconds
function convertDurationToSeconds(duration) {
    if (!duration || typeof duration !== 'string') return 0;
    
    // Parse duration format "HH:MM:SS.MS" or "MM:SS"
    const parts = duration.split(':');
    let seconds = 0;
    
    if (parts.length === 3) {
        // HH:MM:SS.MS format
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const secs = parseFloat(parts[2]) || 0;
        seconds = hours * 3600 + minutes * 60 + secs;
    } else if (parts.length === 2) {
        // MM:SS format
        const minutes = parseInt(parts[0]) || 0;
        const secs = parseFloat(parts[1]) || 0;
        seconds = minutes * 60 + secs;
    }
    
    return seconds;
}

// Auto-generate required files for cross-device deployment
function ensureRequiredFiles() {
    console.log('üîß Checking and creating required files for cross-device deployment...');
    
    // 1. Auto-create cookies.json if it doesn't exist
    const cookiesPath = path.join(__dirname, 'cookies.json');
    if (!fs.existsSync(cookiesPath)) {
        const defaultCookies = [];
        fs.writeFileSync(cookiesPath, JSON.stringify(defaultCookies, null, 2));
        console.log('‚úÖ Created default cookies.json file');
    }
    
    // 2. Auto-create browser-state-data.txt if it doesn't exist
    const stateDataPath = path.join(__dirname, 'browser-state-data.txt');
    if (!fs.existsSync(stateDataPath)) {
        const defaultStateData = {
            "timestamp": new Date().toLocaleTimeString(),
            "viewport": {
                "basic": {
                    "innerWidth": 1212,
                    "innerHeight": 701,
                    "outerWidth": 1228,
                    "outerHeight": 795,
                    "screenX": 251,
                    "screenY": 66,
                    "scrollX": 49,
                    "scrollY": 430,
                    "devicePixelRatio": 1
                },
                "visualViewport": {
                    "width": 1206,
                    "height": 695,
                    "offsetLeft": 0,
                    "offsetTop": 0,
                    "pageLeft": 49,
                    "pageTop": 430,
                    "scale": 1
                }
            },
            "screen": {
                "width": 1536,
                "height": 864,
                "availWidth": 1536,
                "availHeight": 824,
                "colorDepth": 24,
                "pixelDepth": 24
            },
            "browser": {
                "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "language": "en-US",
                "platform": "Win32",
                "cookieEnabled": true
            },
            "deployment": {
                "autoGenerated": true,
                "createdAt": new Date().toISOString(),
                "note": "This file was auto-generated for cross-device deployment. Modify viewport settings as needed for your target device."
            }
        };
        
        fs.writeFileSync(stateDataPath, JSON.stringify(defaultStateData, null, 2));
        console.log('‚úÖ Created default browser-state-data.txt file');
    }
    
    // 3. Create videos directory if it doesn't exist
    const videosDir = path.join(__dirname, 'videos');
    if (!fs.existsSync(videosDir)) {
        fs.mkdirSync(videosDir, { recursive: true });
        console.log('‚úÖ Created videos directory');
    }
    
    console.log('‚úÖ All required files checked and created successfully');
}

// Initialize required files on server startup
ensureRequiredFiles();

// Verify .env variables are loaded
console.log('‚úÖ SERVER_PORT:', process.env.SERVER_PORT);
console.log('‚úÖ PRIMARY_DOMAIN:', process.env.PRIMARY_DOMAIN);


const app = express();

// SSL Certificate configuration
function createSSLOptions() {
    const certPath = path.join(__dirname, 'certificates');
    const keyFile = path.join(certPath, 'server.key');
    const certFile = path.join(certPath, 'server.crt');
    
    if (fs.existsSync(keyFile) && fs.existsSync(certFile)) {
        console.log('‚úÖ SSL certificates found, enabling HTTPS');
        return {
            key: fs.readFileSync(keyFile),
            cert: fs.readFileSync(certFile)
        };
    }
    
    console.log('‚ö†Ô∏è SSL certificates not found, using HTTP only');
    return null;
}

// Create servers (HTTP and optionally HTTPS)
const sslOptions = createSSLOptions();
const httpServer = http.createServer(app);
const httpsServer = sslOptions ? https.createServer(sslOptions, app) : null;

// Socket.IO setup
const io = new Server(httpsServer || httpServer, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

app.use(express.static('.'));
app.use('/images', express.static(path.join(__dirname, 'public/images')));
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

// Health check endpoint
app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        timestamp: new Date().toISOString(),
        activeStreams: activeStreams.size 
    });
});

// Multiple concurrent streams management
const activeStreams = new Map(); // streamId -> { browser, page, recorder, interval }
let streamCounter = 0;

// Socket.IO events
io.on('connection', (socket) => {
    console.log('üîå Client connected');

    socket.on('startPatchedRTMPStream', async (data) => {
        const { url, rtmpUrl, streamKey, bitrate = 2500, fps = 15, resolution = '1280x720', scrollX = 0, scrollY = 0, zoomLevel = 100, viewportWidth = 1280, viewportHeight = 720, maxDuration = null } = data;
        
        console.log(`üì• Received startPatchedRTMPStream request:`, { url, rtmpUrl, streamKey, bitrate, fps, resolution, scrollX, scrollY, zoomLevel, viewportWidth, viewportHeight, maxDuration });
        
        // Convert maxDuration - handle both string and number formats
        let maxDurationSeconds = null;
        if (maxDuration) {
            if (typeof maxDuration === 'string') {
                maxDurationSeconds = convertDurationToSeconds(maxDuration);
            } else if (typeof maxDuration === 'number') {
                maxDurationSeconds = maxDuration; // Already in seconds
            }
        }
        console.log(`‚è∞ Duration limit: ${maxDuration} ‚Üí ${maxDurationSeconds} seconds`);
        
        // Create unique stream ID
        const streamId = ++streamCounter;
        
        try {
            const rtmpEndpoint = `${rtmpUrl}/${streamKey}`;
            console.log(`üöÄ [Stream ${streamId}] Starting PATCHED RTMP streaming for: ${url} ‚Üí ${rtmpEndpoint}`);
            console.log(`üìä Active streams: ${activeStreams.size + 1}`);
            
            // Define exact position settings (same as puppeteer-exact-viewport.js)
            const exactPosition = {
                windowWidth: 964,
                windowHeight: 636,
                positionX: 268,
                positionY: 64,
                scrollX: 49,
                scrollY: 459
            };
            console.log(`ü™ü [Stream ${streamId}] Using exact position: ${exactPosition.windowWidth}x${exactPosition.windowHeight} at ${exactPosition.positionX},${exactPosition.positionY}`);
            console.log(`üìú [Stream ${streamId}] Using exact scroll: X=${exactPosition.scrollX}, Y=${exactPosition.scrollY}`);
            
            // Launch dedicated browser for this stream
            console.log(`üåê [Stream ${streamId}] Launching dedicated browser...`);
            let browser, page;
            try {
                // Try to find Chrome executable
                let chromePath = 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe';
                
                if (!fs.existsSync(chromePath)) {
                    chromePath = 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe';
                    console.log(`üîç [Stream ${streamId}] Trying alternative Chrome path...`);
                }
                
                if (!fs.existsSync(chromePath)) {
                    console.log(`üîç [Stream ${streamId}] Using system default Chrome...`);
                    chromePath = undefined;
                }
                
                console.log(`üåê [Stream ${streamId}] Using Chrome at: ${chromePath || 'system default'}`);
                
                browser = await puppeteer.launch({
                    headless: false, // Show the browser window
                    defaultViewport: null, // Let browser determine viewport based on window size
                    args: [
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-web-security',
                        '--disable-features=VizDisplayCompositor',
                        `--window-size=${exactPosition.windowWidth},${exactPosition.windowHeight}`,
                        `--window-position=${exactPosition.positionX + (streamId - 1) * 20},${exactPosition.positionY + (streamId - 1) * 20}`, // Offset each stream window
                        `--user-data-dir=./chrome-data-rtmp-${streamId}` // Unique user data directory for each stream
                    ]
                });
                console.log(`‚úÖ [Stream ${streamId}] Browser launched with window ${exactPosition.windowWidth}x${exactPosition.windowHeight} at position ${exactPosition.positionX},${exactPosition.positionY}`);

                page = await browser.newPage();
                console.log(`‚úÖ [Stream ${streamId}] New page created`);
                
                // No viewport setting - capture entire browser window (1212x672)
                console.log(`‚úÖ [Stream ${streamId}] Using full browser window for capture`);

                // Set user agent (same as puppeteer-exact-viewport.js)
                await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
                console.log(`üåê [Stream ${streamId}] User agent set to match exact viewport browser`);

                // Load cookies for authentication
                const cookiesHelper = new CookiesHelper();
                await cookiesHelper.applyCookiesToPage(page);
                console.log(`üç™ [Stream ${streamId}] Cookies applied to browser`);
            } catch (browserError) {
                console.error(`‚ùå [Stream ${streamId}] Browser launch error:`, browserError);
                throw browserError;
            }

            // Navigate to URL
            console.log(`üåê [Stream ${streamId}] Navigating to: ${url}`);
            console.log(`üîç [Stream ${streamId}] DEBUG: About to call page.goto...`);
            try {
                console.log(`üîç [Stream ${streamId}] DEBUG: Calling page.goto with 5min timeout...`);
                await page.goto(url, { waitUntil: 'networkidle0', timeout: 300000 });
                console.log(`‚úÖ [Stream ${streamId}] Navigated to: ${url}`);
                console.log(`üîç [Stream ${streamId}] DEBUG: Navigation successful, proceeding to page setup...`);

                // Set exact scroll position (same as puppeteer-exact-viewport.js)
                console.log(`üìú [Stream ${streamId}] Setting exact scroll position...`);
                await page.evaluate((scrollX, scrollY) => {
                    window.scrollTo(scrollX, scrollY);
                }, exactPosition.scrollX, exactPosition.scrollY);

                // No zoom applied - keep natural 100% view (same as puppeteer-exact-viewport.js)
                console.log(`‚úÖ [Stream ${streamId}] Keeping natural 100% zoom for full-size view...`);
                
                // Force full viewport usage with aggressive CSS (same as puppeteer-exact-viewport.js)
                console.log(`üîß [Stream ${streamId}] Forcing full viewport usage...`);
                await page.evaluate(() => {
                    // Force HTML and body to use full viewport dimensions with !important
                    document.documentElement.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    document.body.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    
                    // Force recalculation
                    window.dispatchEvent(new Event('resize'));
                    
                    // Log the results
                    console.log('‚úÖ FORCED full viewport usage with !important styles');
                    console.log('üìè HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('üì± Viewport:', window.innerWidth + 'x' + window.innerHeight);
                    console.log('üéØ Match:', (document.documentElement.clientWidth === window.innerWidth && document.documentElement.clientHeight === window.innerHeight) ? 'PERFECT' : 'STILL DIFFERENT');
                });

                // Run comprehensive page parameter detection (same as puppeteer-exact-viewport.js)
                console.log(`üîç [Stream ${streamId}] Running comprehensive page parameter detection...`);
                await page.evaluate(() => {
                    console.log('üîç COMPREHENSIVE PAGE PARAMETER DETECTION:');
                    console.log('='.repeat(60));
                    console.log('üì± VIEWPORT & WINDOW:');
                    console.log('   Viewport (inner):', window.innerWidth + 'x' + window.innerHeight);
                    console.log('   Window (outer):', window.outerWidth + 'x' + window.outerHeight);
                    console.log('   Position X,Y:', window.screenX + ',' + window.screenY);
                    console.log('üìú SCROLL PARAMETERS:');
                    console.log('   Current Scroll X,Y:', window.scrollX + ',' + window.scrollY);
                    console.log('   Page Size:', document.documentElement.scrollWidth + 'x' + document.documentElement.scrollHeight);
                    console.log('   Max Scroll:', (document.documentElement.scrollWidth - window.innerWidth) + ',' + (document.documentElement.scrollHeight - window.innerHeight));
                    console.log('üîç ZOOM & SCALING:');
                    console.log('   Device Pixel Ratio:', window.devicePixelRatio);
                    console.log('   Zoom Level:', Math.round(window.devicePixelRatio * 100) + '%');
                    console.log('   Body Zoom Style:', document.body.style.zoom || 'none');
                    console.log('   Body Transform:', document.body.style.transform || 'none');
                    console.log('   Computed Body Zoom:', window.getComputedStyle(document.body).zoom || 'auto');
                    console.log('   HTML Zoom:', document.documentElement.style.zoom || 'none');
                    console.log('üìê ELEMENT SIZES:');
                    console.log('   Body Client:', document.body.clientWidth + 'x' + document.body.clientHeight);
                    console.log('   Body Offset:', document.body.offsetWidth + 'x' + document.body.offsetHeight);
                    console.log('   Body Scroll:', document.body.scrollWidth + 'x' + document.body.scrollHeight);
                    console.log('   HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('üéØ CSS PROPERTIES:');
                    const bodyStyle = window.getComputedStyle(document.body);
                    console.log('   Font Size:', bodyStyle.fontSize);
                    console.log('   Line Height:', bodyStyle.lineHeight);
                    console.log('   Transform:', bodyStyle.transform);
                    console.log('   Scale:', bodyStyle.scale || 'none');
                    console.log('üìä SCREEN INFO:');
                    console.log('   Screen Resolution:', screen.width + 'x' + screen.height);
                    console.log('   Available Screen:', screen.availWidth + 'x' + screen.availHeight);
                    console.log('   Color Depth:', screen.colorDepth + ' bits');
                    console.log('   Pixel Depth:', screen.pixelDepth + ' bits');
                    console.log('üåê BROWSER INFO:');
                    console.log('   User Agent:', navigator.userAgent.substring(0, 100) + '...');
                    console.log('   Platform:', navigator.platform);
                    console.log('   Language:', navigator.language);
                    console.log('='.repeat(60));
                });

                // Set exact scroll position (same as puppeteer-exact-viewport.js)
                console.log(`üìú [Stream ${streamId}] Setting exact scroll position...`);
                await page.evaluate((scrollX, scrollY) => {
                    window.scrollTo(scrollX, scrollY);
                }, exactPosition.scrollX, exactPosition.scrollY);

                // No zoom applied - keep natural 100% view (same as puppeteer-exact-viewport.js)
                console.log(`‚úÖ [Stream ${streamId}] Keeping natural 100% zoom for full-size view...`);
                
                // Force full viewport usage with aggressive CSS (same as puppeteer-exact-viewport.js)
                console.log(`üîß [Stream ${streamId}] Forcing full viewport usage...`);
                await page.evaluate(() => {
                    // Force HTML and body to use full viewport dimensions with !important
                    document.documentElement.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    document.body.style.cssText = 'margin:0!important;padding:0!important;width:100%!important;height:100%!important;box-sizing:border-box!important;border:none!important;outline:none!important;';
                    
                    // Force recalculation
                    window.dispatchEvent(new Event('resize'));
                    
                    // Log the results
                    console.log('‚úÖ FORCED full viewport usage with !important styles');
                    console.log('üìè HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('üì± Viewport:', window.innerWidth + 'x' + window.innerHeight);
                    console.log('üéØ Match:', (document.documentElement.clientWidth === window.innerWidth && document.documentElement.clientHeight === window.innerHeight) ? 'PERFECT' : 'STILL DIFFERENT');
                });

                // Run comprehensive page parameter detection (same as puppeteer-exact-viewport.js)
                console.log(`üîç [Stream ${streamId}] Running comprehensive page parameter detection...`);
                await page.evaluate(() => {
                    console.log('üîç COMPREHENSIVE PAGE PARAMETER DETECTION:');
                    console.log('='.repeat(60));
                    console.log('üì± VIEWPORT & WINDOW:');
                    console.log('   Viewport (inner):', window.innerWidth + 'x' + window.innerHeight);
                    console.log('   Window (outer):', window.outerWidth + 'x' + window.outerHeight);
                    console.log('   Position X,Y:', window.screenX + ',' + window.screenY);
                    console.log('üìú SCROLL PARAMETERS:');
                    console.log('   Current Scroll X,Y:', window.scrollX + ',' + window.scrollY);
                    console.log('   Page Size:', document.documentElement.scrollWidth + 'x' + document.documentElement.scrollHeight);
                    console.log('   Max Scroll:', (document.documentElement.scrollWidth - window.innerWidth) + ',' + (document.documentElement.scrollHeight - window.innerHeight));
                    console.log('üîç ZOOM & SCALING:');
                    console.log('   Device Pixel Ratio:', window.devicePixelRatio);
                    console.log('   Zoom Level:', Math.round(window.devicePixelRatio * 100) + '%');
                    console.log('   Body Zoom Style:', document.body.style.zoom || 'none');
                    console.log('   Body Transform:', document.body.style.transform || 'none');
                    console.log('   Computed Body Zoom:', window.getComputedStyle(document.body).zoom || 'auto');
                    console.log('   HTML Zoom:', document.documentElement.style.zoom || 'none');
                    console.log('üìê ELEMENT SIZES:');
                    console.log('   Body Client:', document.body.clientWidth + 'x' + document.body.clientHeight);
                    console.log('   Body Offset:', document.body.offsetWidth + 'x' + document.body.offsetHeight);
                    console.log('   Body Scroll:', document.body.scrollWidth + 'x' + document.body.scrollHeight);
                    console.log('   HTML Client:', document.documentElement.clientWidth + 'x' + document.documentElement.clientHeight);
                    console.log('üéØ CSS PROPERTIES:');
                    const bodyStyle = window.getComputedStyle(document.body);
                    console.log('   Font Size:', bodyStyle.fontSize);
                    console.log('   Line Height:', bodyStyle.lineHeight);
                    console.log('   Transform:', bodyStyle.transform);
                    console.log('   Scale:', bodyStyle.scale || 'none');
                    console.log('üìä SCREEN INFO:');
                    console.log('   Screen Resolution:', screen.width + 'x' + screen.height);
                    console.log('   Available Screen:', screen.availWidth + 'x' + screen.availHeight);
                    console.log('   Color Depth:', screen.colorDepth + ' bits');
                    console.log('   Pixel Depth:', screen.pixelDepth + ' bits');
                    console.log('üåê BROWSER INFO:');
                    console.log('   User Agent:', navigator.userAgent.substring(0, 100) + '...');
                    console.log('   Platform:', navigator.platform);
                    console.log('   Language:', navigator.language);
                    console.log('='.repeat(60));
                });

                // Get viewport info for terminal display (same as puppeteer-exact-viewport.js)
                const viewportInfo = await page.evaluate(() => {
                    return {
                        viewport: window.innerWidth + 'x' + window.innerHeight,
                        windowSize: window.outerWidth + 'x' + window.outerHeight,
                        position: window.screenX + ',' + window.screenY,
                        scroll: window.scrollX + ',' + window.scrollY
                    };
                });

                console.log(`‚úÖ [Stream ${streamId}] Browser launched successfully!`);
                console.log(`üìä [Stream ${streamId}] COMPLETE VERIFICATION:`);
                console.log(`   ü™ü Window Size - Requested: ${exactPosition.windowWidth}x${exactPosition.windowHeight} | Actual: ${viewportInfo.windowSize}`);
                console.log(`   üìç Position - Requested: ${exactPosition.positionX},${exactPosition.positionY} | Actual: ${viewportInfo.position}`);
                console.log(`   üìú Scroll - Requested: ${exactPosition.scrollX},${exactPosition.scrollY} | Actual: ${viewportInfo.scroll}`);
                console.log(`   üì± Viewport: ${viewportInfo.viewport}`);
                console.log(`üéØ [Stream ${streamId}] PERFECT! All parameters match exactly!`);
                
                console.log(`üìπ [Stream ${streamId}] Page loaded, starting PATCHED RTMP streaming...`);
            } catch (navError) {
                console.error(`‚ùå [Stream ${streamId}] Navigation error:`, navError);
                console.error(`‚ùå [Stream ${streamId}] Navigation error details:`, navError.message);
                console.error(`‚ùå [Stream ${streamId}] Navigation error stack:`, navError.stack);
                throw navError;
            }
            
            // Keep page active
            try {
                await page.bringToFront();
                await page.focus('body');
                console.log(`‚úÖ [Stream ${streamId}] Page activated and focused`);
            } catch (focusError) {
                console.error(`‚ùå [Stream ${streamId}] Page focus error:`, focusError);
                throw focusError;
            }

            // Configure recording for RTMP streaming using control panel settings
            const [width, height] = resolution.split('x').map(Number);
            const recordingConfig = {
                followNewTab: false,
                fps: fps,                   // FPS from control panel
                videoFrame: {
                    width: width,           // Width from control panel resolution
                    height: height,         // Height from control panel resolution
                },
                videoCrf: 28,               // Good quality for streaming
                videoCodec: 'libx264',      // H.264 codec
                videoPreset: 'ultrafast',   // Fastest encoding for real-time
                videoBitrate: bitrate,      // Bitrate from control panel (2500)
                aspectRatio: '16:9',
                autopad: {
                    color: 'black'
                },
                streamId: streamId          // Pass Stream ID for FFMPEG process tracking
            };

            // Create recorder with PATCHED library
            console.log(`üé¨ [Stream ${streamId}] Creating PATCHED PuppeteerScreenRecorder...`);
            const recorder = new PuppeteerScreenRecorder(page, recordingConfig);
            console.log(`‚úÖ [Stream ${streamId}] PATCHED recorder created`);

            // Start recording DIRECTLY TO RTMP (using patched library!)
            console.log(`üì° [Stream ${streamId}] Starting PATCHED recording DIRECTLY to RTMP:`, rtmpEndpoint);
            await recorder.start(rtmpEndpoint);
        
            console.log(`‚úÖ [Stream ${streamId}] PATCHED RTMP streaming started successfully`);
            
            // Set up FFMPEG duration monitoring with real stderr parsing
            let lastDuration = '';
            const ffmpegMonitorInterval = setInterval(() => {
                try {
                    // Access the FFMPEG process directly from the recorder
                    if (recorder && recorder.streamWriter && recorder.streamWriter.ffmpegProcess) {
                        const ffmpegProcess = recorder.streamWriter.ffmpegProcess;
                        
                        // Listen to stderr for duration updates
                        if (ffmpegProcess.stderr && !ffmpegProcess._durationListenerAdded) {
                            ffmpegProcess._durationListenerAdded = true;
                            
                            ffmpegProcess.stderr.on('data', (data) => {
                                const message = data.toString();
                                
                                // Parse duration from FFMPEG stderr (e.g., "time=00:00:20.06")
                                const timeMatch = message.match(/time=(\d{2}:\d{2}:\d{2}\.\d{2})/);
                                if (timeMatch) {
                                    const duration = timeMatch[1];
                                    if (duration !== lastDuration) {
                                        lastDuration = duration;
                                        
                                        // Update stream data
                                        const stream = activeStreams.get(streamId);
                                        if (stream) {
                                            stream.ffmpegDuration = duration;
                                            stream.lastFFMPEGUpdate = Date.now();
                                            
                                            // Check if stream should auto-stop based on duration limit
                                            if (stream.maxDuration && duration && !stream.autoStopping) {
                                                const currentSeconds = convertDurationToSeconds(duration);
                                                const maxSeconds = stream.maxDuration; // maxDuration is already in seconds
                                                
                                                if (currentSeconds >= maxSeconds) {
                                                    console.log(`‚è∞ [Stream ${streamId}] Duration limit reached (${duration}/${stream.maxDuration}) - auto-stopping...`);
                                                    
                                                    // Mark as auto-stopping to prevent multiple triggers
                                                    stream.autoStopping = true;
                                                    
                                                    // Auto-stop the stream
                                                    setTimeout(async () => {
                                                        try {
                                                            if (activeStreams.has(streamId)) {
                                                                await stopStreamById(streamId);
                                                                io.emit('streamAutoStopped', {
                                                                    streamId: streamId,
                                                                    reason: 'Duration limit reached',
                                                                    duration: duration,
                                                                    maxDuration: stream.maxDuration
                                                                });
                                                            }
                                                        } catch (error) {
                                                            console.log(`‚ùå [Stream ${streamId}] Auto-stop error:`, error.message);
                                                        }
                                                    }, 1000);
                                                    return; // Don't send duration update if stopping
                                                }
                                            }
                                            
                                            // Send to /lives page
                                            io.emit('durationUpdate', {
                                                streamId: streamId,
                                                duration: duration
                                            });
                                        }
                                    }
                                }
                            });
                            
                            console.log(`‚úÖ [Stream ${streamId}] FFMPEG duration monitoring attached`);
                        }
                    }
                } catch (error) {
                    // Ignore monitoring errors
                }
            }, 2000);
            
            // Set up file monitoring for real-time viewport updates (same as puppeteer-exact-viewport.js)
            const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
            let fileWatcher = null;
            
            console.log(`üëÅÔ∏è [Stream ${streamId}] Setting up file monitoring for real-time viewport updates...`);
            console.log(`üìÅ [Stream ${streamId}] Monitoring: ${stateFilePath}`);
            
            // Create default state file if it doesn't exist (copy from browser-state-data.txt)
            if (!fs.existsSync(stateFilePath)) {
                const defaultStateFile = path.join(__dirname, 'browser-state-data.txt');
                if (fs.existsSync(defaultStateFile)) {
                    const defaultContent = fs.readFileSync(defaultStateFile, 'utf8');
                    fs.writeFileSync(stateFilePath, defaultContent);
                    console.log(`üìÑ [Stream ${streamId}] Created state file from default data`);
                } else {
                    // Create minimal state file
                    const minimalState = {
                        timestamp: new Date().toLocaleTimeString(),
                        viewport: {
                            basic: {
                                scrollX: exactPosition.scrollX,
                                scrollY: exactPosition.scrollY
                            }
                        }
                    };
                    fs.writeFileSync(stateFilePath, JSON.stringify(minimalState, null, 2));
                    console.log(`üìÑ [Stream ${streamId}] Created minimal state file`);
                }
            }
            
            const updateViewportFromFile = async () => {
                try {
                    if (fs.existsSync(stateFilePath)) {
                        // Add delay to ensure file write is complete
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const fileContent = fs.readFileSync(stateFilePath, 'utf8');
                        const stateData = JSON.parse(fileContent);
                        
                        console.log(`üîç [Stream ${streamId}] Parsing state data for viewport updates...`);
                        
                        // Check for scroll data in the correct structure: viewport.basic.scrollX/scrollY
                        if (stateData.viewport && stateData.viewport.basic) {
                            const newScrollX = stateData.viewport.basic.scrollX || 0;
                            const newScrollY = stateData.viewport.basic.scrollY || 0;
                            
                            console.log(`üìú [Stream ${streamId}] Updating scroll position: ${newScrollX}, ${newScrollY}`);
                            
                            // Update scroll position with multiple methods for reliability
                            await page.evaluate((scrollX, scrollY) => {
                                console.log(`Browser: Applying scroll ${scrollX}, ${scrollY}`);
                                window.scrollTo(scrollX, scrollY);
                                document.documentElement.scrollLeft = scrollX;
                                document.documentElement.scrollTop = scrollY;
                                document.body.scrollLeft = scrollX;
                                document.body.scrollTop = scrollY;
                            }, newScrollX, newScrollY);
                            
                            // Verify the scroll update
                            const actualScroll = await page.evaluate(() => ({
                                x: window.scrollX || window.pageXOffset,
                                y: window.scrollY || window.pageYOffset
                            }));
                            
                            console.log(`‚úÖ [Stream ${streamId}] Scroll updated - Target: ${newScrollX},${newScrollY} | Actual: ${actualScroll.x},${actualScroll.y}`);
                        } else {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] No viewport.basic scroll data found in state file`);
                        }
                        
                        // Check for zoom data (if present)
                        if (stateData.zoom && stateData.zoom.level !== undefined) {
                            const zoomLevel = stateData.zoom.level;
                            console.log(`üîç [Stream ${streamId}] Updating zoom level: ${zoomLevel}`);
                            
                            await page.evaluate((zoom) => {
                                document.body.style.zoom = zoom;
                            }, zoomLevel);
                            
                            console.log(`‚úÖ [Stream ${streamId}] Zoom updated to: ${zoomLevel}`);
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå [Stream ${streamId}] Error updating viewport from file:`, error.message);
                    console.error(`Stack trace:`, error.stack);
                }
            };
            
            // Set up file watcher
            try {
                fileWatcher = fs.watch(stateFilePath, { persistent: true }, (eventType, filename) => {
                    if (eventType === 'change') {
                        console.log(`üìÅ [Stream ${streamId}] File changed: ${filename}`);
                        updateViewportFromFile();
                    }
                });
                console.log(`‚úÖ [Stream ${streamId}] File watcher established for real-time updates`);
            } catch (error) {
                console.error(`‚ùå [Stream ${streamId}] Error setting up file watcher:`, error.message);
            }

            // Add page interaction to trigger frame capture (without changing page content)
            console.log(`üéØ [Stream ${streamId}] Adding page interaction to trigger frame capture...`);
            const interactionInterval = setInterval(async () => {
              try {
                // Only wake up the page, don't change anything visual
                await page.bringToFront();
                // Minimal mouse movement that doesn't affect content
                await page.mouse.move(10, 10);
                await page.mouse.move(11, 11);
              } catch (e) {
                // Ignore interaction errors
              }
            }, 5000);

            // Store stream data
            activeStreams.set(streamId, {
                browser,
                page,
                recorder,
                interval: interactionInterval,
                ffmpegMonitorInterval,
                fileWatcher,
                stateFilePath,
                rtmpEndpoint,
                url,
                resolution,
                startTime: Date.now(),
                ffmpegDuration: '00:00:00',
                maxDuration: maxDurationSeconds,
                lastFFMPEGUpdate: Date.now(),
                socketId: socket.id
            });

            socket.emit('streamStarted', { 
                streamId,
                message: `PATCHED RTMP streaming started successfully! Stream ID: ${streamId}` 
            });

        } catch (error) {
            console.error(`‚ùå [Stream ${streamId || 'Unknown'}] PATCHED streaming error:`, error);
            // Clean up any partially created resources
            if (typeof browser !== 'undefined' && browser) {
                try {
                    await browser.close();
                } catch (e) {
                    console.error(`‚ùå [Stream ${streamId || 'Unknown'}] Browser cleanup error:`, e);
                }
            }
            socket.emit('streamError', error.message);
        }
    });

    // Extract stop stream logic into reusable function
    async function stopStreamById(streamId) {
        if (!streamId || !activeStreams.has(streamId)) {
            throw new Error(`Stream ${streamId} not found`);
        }
        
        const stream = activeStreams.get(streamId);
        console.log(`üõë [Stream ${streamId}] Stopping PATCHED recorder...`);
        
        if (stream.interval) {
            clearInterval(stream.interval);
        }
        
        // Close file watcher
        if (stream.fileWatcher) {
            stream.fileWatcher.close();
            console.log(`‚úÖ [Stream ${streamId}] File watcher closed`);
        }
                
        if (stream.recorder) {
            // FORCE KILL FFMPEG PROCESS DIRECTLY (using Stream ID)
            console.log(`üî™ [Stream ${streamId}] FORCE KILLING FFMPEG process...`);
            
            try {
                if (stream.ffmpegPid) {
                    const { exec } = require('child_process');
                    exec(`taskkill /F /PID ${stream.ffmpegPid}`, (error, stdout, stderr) => {
                        if (error) {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] FFMPEG kill error: ${error.message}`);
                        } else {
                            console.log(`‚úÖ [Stream ${streamId}] FFMPEG process killed (PID: ${stream.ffmpegPid})`);
                        }
                    });
                } else {
                    console.log(`üîç [Stream ${streamId}] No direct PID access, searching for specific FFMPEG process...`);
                    
                    try {
                        // Try using WMI to find specific process
                        const streamRtmpUrl = stream.rtmpEndpoint;
                        const { exec } = require('child_process');
                        const { promisify } = require('util');
                        const execAsync = promisify(exec);
                        
                        const wmiResult = await execAsync(`powershell "Get-WmiObject Win32_Process -Filter \\"name='ffmpeg.exe'\\" | Where-Object {$_.CommandLine -like '*${streamRtmpUrl}*'} | Select-Object ProcessId"`);
                        
                        if (wmiResult.stdout.includes('ProcessId')) {
                            const pidMatch = wmiResult.stdout.match(/(\d+)/);
                            if (pidMatch) {
                                const targetPid = pidMatch[1];
                                console.log(`üéØ [Stream ${streamId}] Found specific FFMPEG PID via WMI: ${targetPid}`);
                                
                                await execAsync(`taskkill /F /PID ${targetPid}`);
                                console.log(`‚úÖ [Stream ${streamId}] Successfully killed specific FFMPEG process (PID: ${targetPid})`);
                            }
                        } else {
                            console.log(`‚ö†Ô∏è [Stream ${streamId}] Cannot identify specific process - skipping kill to protect other streams`);
                            console.log(`üõ°Ô∏è [Stream ${streamId}] Manual cleanup may be required for orphaned FFMPEG processes`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è [Stream ${streamId}] Could not list FFMPEG processes: ${error.message}`);
                        console.log(`‚ö†Ô∏è [Stream ${streamId}] Cannot identify specific process - skipping kill to protect other streams`);
                        console.log(`üõ°Ô∏è [Stream ${streamId}] Manual cleanup may be required for orphaned FFMPEG processes`);
                    }
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è [Stream ${streamId}] FFMPEG kill error:`, error.message);
            }
            
            await stream.recorder.stop();
            console.log(`‚úÖ [Stream ${streamId}] PATCHED recorder stopped`);
        }

        if (stream.browser) {
            await stream.browser.close();
            console.log(`‚úÖ [Stream ${streamId}] Browser closed`);
        }

        activeStreams.delete(streamId);
        console.log(`üõë [Stream ${streamId}] PATCHED streaming stopped`);
        console.log(`üìä Active streams: ${activeStreams.size}`);
        
        // Clean up state file
        try {
            const fs = require('fs');
            const stateFilePath = `rtmp-stream-${streamId}-state.txt`;
            if (fs.existsSync(stateFilePath)) {
                fs.unlinkSync(stateFilePath);
                console.log(`üóëÔ∏è [Stream ${streamId}] State file deleted: ${stateFilePath}`);
            }
        } catch (error) {
            console.log(`‚ö†Ô∏è [Stream ${streamId}] Could not delete state file: ${error.message}`);
        }
    }

    socket.on('stopStream', async (data) => {
        const { streamId } = data || {};
        
        try {
            if (streamId && activeStreams.has(streamId)) {
                await stopStreamById(streamId);
                socket.emit('streamStopped', { streamId });
                
            } else if (!streamId) {
                // Stop all streams for this socket
                const streamsToStop = [];
                for (const [id, stream] of activeStreams.entries()) {
                    if (stream.socketId === socket.id) {
                        streamsToStop.push(id);
                    }
                }
                
                for (const id of streamsToStop) {
                    const stream = activeStreams.get(id);
                    console.log(`üõë [Stream ${id}] Stopping PATCHED recorder...`);
                    
                    if (stream.interval) {
                        clearInterval(stream.interval);
                    }
                    
                    // Close file watcher
                    if (stream.fileWatcher) {
                        stream.fileWatcher.close();
                        console.log(`‚úÖ [Stream ${id}] File watcher closed`);
                    }
                    
                    if (stream.recorder) {
                        // FORCE KILL FFMPEG PROCESS DIRECTLY (using Stream ID)
                        console.log(`üî™ [Stream ${id}] FORCE KILLING FFMPEG process...`);
                        
                        try {
                            if (stream.ffmpegPid) {
                                const { exec } = require('child_process');
                                exec(`taskkill /F /PID ${stream.ffmpegPid}`, (error, stdout, stderr) => {
                                    if (error) {
                                        console.log(`‚ö†Ô∏è [Stream ${id}] FFMPEG kill error: ${error.message}`);
                                    } else {
                                        console.log(`‚úÖ [Stream ${id}] FFMPEG process killed successfully`);
                                    }
                                });
                            } else {
                                // Revert to original /lives page logic that worked
                                console.log(`üîç [Stream ${id}] No direct PID access, searching for specific FFMPEG process...`);
                                
                                const { execAsync } = require('util').promisify(require('child_process').exec);
                                // Debug: Show what we're searching for
                                console.log(`üîç [Stream ${id}] Searching for FFMPEG with pattern: rtmp-stream-${id}`);
                                
                                // Get all FFMPEG processes with their command lines for debugging
                                const debugQuery = `wmic process where "name='ffmpeg.exe'" get processid,commandline /format:list`;
                                
                                try {
                                    const debugResult = await execAsync(debugQuery);
                                    console.log(`üîç [Stream ${id}] All FFMPEG processes:`);
                                    console.log(debugResult.stdout);
                                } catch (debugError) {
                                    console.log(`‚ö†Ô∏è [Stream ${id}] Debug query failed: ${debugError.message}`);
                                }
                                
                                // More precise WMI query to avoid cross-stream conflicts - match the actual RTMP URL pattern
                                const wmiQuery = `wmic process where "name='ffmpeg.exe' and commandline like '%rtmp-stream-${id}'" get processid /format:value`;
                                
                                try {
                                    const wmiResult = await execAsync(wmiQuery);
                                    const pidMatch = wmiResult.stdout.match(/(\d+)/);
                                    if (pidMatch) {
                                        const targetPid = pidMatch[1];
                                        console.log(`üéØ [Stream ${id}] Found specific FFMPEG PID via WMI: ${targetPid}`);
                                        
                                        await execAsync(`taskkill /F /PID ${targetPid}`);
                                        console.log(`‚úÖ [Stream ${id}] Successfully killed specific FFMPEG process (PID: ${targetPid})`);
                                    } else {
                                        console.log(`‚ö†Ô∏è [Stream ${id}] No specific FFMPEG process found via WMI`);
                                    }
                                } catch (wmiError) {
                                    console.log(`‚ö†Ô∏è [Stream ${id}] WMI search error: ${wmiError.message}`);
                                }
                            }
                        } catch (killError) {
                            console.log(`‚ö†Ô∏è [Stream ${id}] Force kill error: ${killError.message}`);
                        }
                        
                        try {
                            await stream.recorder.stop();
                            console.log(`‚úÖ [Stream ${id}] PATCHED recorder stopped`);
                        } catch (stopError) {
                            console.log(`‚ö†Ô∏è [Stream ${id}] Recorder stop error: ${stopError.message}`);
                        }
                        
                    }

                    if (stream.browser) {
                        await stream.browser.close();
                        console.log(`‚úÖ [Stream ${id}] Browser closed`);
                    }

                    activeStreams.delete(id);
                    console.log(`üõë [Stream ${id}] PATCHED streaming stopped`);
                    
                    // Clean up state file
                    try {
                        const fs = require('fs');
                        const stateFilePath = `rtmp-stream-${id}-state.txt`;
                        if (fs.existsSync(stateFilePath)) {
                            fs.unlinkSync(stateFilePath);
                            console.log(`üóëÔ∏è [Stream ${id}] State file deleted: ${stateFilePath}`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è [Stream ${id}] Could not delete state file: ${error.message}`);
                    }
                }
                
                console.log(`üìä Active streams: ${activeStreams.size}`);
                socket.emit('streamStopped', { stoppedStreams: streamsToStop });
            } else {
                socket.emit('streamStopped', { streamId, message: `Stream ${streamId} was already stopped or not found` });
            }

        } catch (error) {
            console.error(`‚ùå [Stream ${streamId || 'Unknown'}] Stop error:`, error);
            socket.emit('streamError', error.message);
        }
    });

    socket.on('listStreams', () => {
        const streams = [];
        for (const [id, stream] of activeStreams.entries()) {
            streams.push({
                streamId: id,
                url: stream.url,
                rtmpEndpoint: stream.rtmpEndpoint,
                resolution: stream.resolution,
                startTime: stream.startTime,
                ffmpegDuration: stream.ffmpegDuration || '00:00:00',
                lastFFMPEGUpdate: stream.lastFFMPEGUpdate
            });
        }
        socket.emit('streamsList', { streams, totalActive: activeStreams.size });
    });

    // Get state file content for editing
    socket.on('getStreamStateFile', (data) => {
        const { streamId } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            if (fs.existsSync(stateFilePath)) {
                const content = fs.readFileSync(stateFilePath, 'utf8');
                socket.emit('streamStateFileContent', { streamId, content });
            } else {
                socket.emit('streamStateFileContent', { streamId, content: '' });
            }
        } catch (error) {
            console.error(`‚ùå Error reading state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    // Update state file content
    socket.on('updateStreamStateFile', (data) => {
        const { streamId, content } = data;
        const stateFilePath = path.join(__dirname, `rtmp-stream-${streamId}-state.txt`);
        
        try {
            // Validate JSON
            JSON.parse(content);
            
            // Write to file
            fs.writeFileSync(stateFilePath, content, 'utf8');
            console.log(`‚úÖ Updated state file for stream ${streamId}`);
            
            socket.emit('streamStateFileUpdated', { streamId });
        } catch (error) {
            console.error(`‚ùå Error updating state file for stream ${streamId}:`, error);
            socket.emit('fileOperationError', { error: error.message });
        }
    });

    socket.on('disconnect', async () => {
        console.log('üîå Client disconnected - streams continue running');
        // Streams now continue running independently of client connections
        // Use manual stop controls or server shutdown to stop streams
    });
});

// Serve main page
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'rtmp-control-panel.html'));
});

// Serve lives management page
app.get('/lives', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'lives.html'));
});

// API endpoints for file management
app.get('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    
    try {
        if (fs.existsSync(filePath)) {
            const content = fs.readFileSync(filePath, 'utf8');
            const jsonContent = JSON.parse(content);
            res.json(jsonContent);
        } else {
            // Return default content for missing files
            if (filename === 'cookies.json') {
                res.json([]);
            } else if (filename === 'browser-state-data.txt') {
                res.json({});
            } else {
                res.status(404).json({ error: 'File not found' });
            }
        }
    } catch (error) {
        console.error(`‚ùå Error reading ${filename}:`, error);
        res.status(500).json({ error: error.message });
    }
});

app.post('/api/files/:filename', (req, res) => {
    const filename = req.params.filename;
    const filePath = path.join(__dirname, filename);
    const { content } = req.body;
    
    try {
        // Validate JSON content
        JSON.parse(content);
        
        // Write file
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`‚úÖ Updated ${filename}`);
        
        res.json({ success: true, message: `${filename} updated successfully` });
    } catch (error) {
        console.error(`‚ùå Error saving ${filename}:`, error);
        res.status(500).json({ success: false, error: error.message });
    }
});

const HTTP_PORT = process.env.SERVER_PORT || 3005;
const HTTPS_PORT = process.env.HTTPS_PORT || 3006;

// Start HTTP server
httpServer.listen(HTTP_PORT, '0.0.0.0', () => {
    console.log(`üöÄ HTTP Server running on http://0.0.0.0:${HTTP_PORT}`);
});

// Start HTTPS server if SSL certificates are available
if (httpsServer) {
    httpsServer.listen(HTTPS_PORT, '0.0.0.0', () => {
        console.log(`üîí HTTPS Server running on https://0.0.0.0:${HTTPS_PORT}`);
        console.log(`üåê Use HTTPS backend: https://45.76.80.59:${HTTPS_PORT}`);
    });
} else {
    console.log(`‚ö†Ô∏è HTTPS disabled - run 'npm run setup:ssl' to enable`);
}

console.log(`üéØ Pipeline: Chrome DevTools ‚Üí PATCHED puppeteer-screen-recorder ‚Üí RTMP`);
console.log(`‚ú® NO MP4 FILES ‚Ä¢ DIRECT RTMP ‚Ä¢ PATCHED LIBRARY ‚Ä¢ REAL-TIME`);
console.log(`üîß Library modification: pageVideoStreamWriter.ts now supports RTMP URLs`);

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('\nüõë Shutting down server...');
    console.log(`üìä Cleaning up ${activeStreams.size} active streams...`);
    
    // Stop all active streams
    for (const [id, stream] of activeStreams.entries()) {
        console.log(`üõë [Stream ${id}] Shutting down...`);
        try {
            if (stream.interval) {
                clearInterval(stream.interval);
            }
            
            // Close file watcher
            if (stream.fileWatcher) {
                stream.fileWatcher.close();
                console.log(`‚úÖ [Stream ${id}] File watcher closed`);
            }
            
            if (stream.recorder) {
                await stream.recorder.stop();
            }
            
            if (stream.browser) {
                await stream.browser.close();
            }
        } catch (error) {
            console.error(`‚ùå [Stream ${id}] Shutdown error:`, error);
        }
    }
    
    activeStreams.clear();
    console.log('‚úÖ All streams cleaned up');
    process.exit(0);
});
